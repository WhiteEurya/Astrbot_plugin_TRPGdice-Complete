import random
import datetime
import hashlib
import ast


from astrbot.api.event import filter, AstrMessageEvent
from astrbot.api.star import Context, Star, register
from astrbot.api.all import *

# ======================== #
import json
import re
import time
import os
import uuid
import sqlite3
from faker import Faker

PLUGIN_DIR = os.path.dirname(os.path.abspath(__file__))
DATA_FOLDER = PLUGIN_DIR + "/chara_data/"  # Â≠òÂÇ®‰∫∫Áâ©Âç°ÁöÑÊñá‰ª∂Â§π

#ÂÖàÊîªË°®
init_list = {}
current_index = {}

DEFAULT_DICE = 100

log_help_str = '''.log Êåá‰ª§‰∏ÄËßàÔºö
    .log on -- ÂºÄÂêØlogËÆ∞ÂΩï„ÄÇ‰∫öÊâòËéâ‰ºöËÆ∞ÂΩï‰πãÂêéÊâÄÊúâÁöÑÂØπËØùÔºåÂπ∂‰øùÂ≠òÂú®‚ÄúÁæ§Âêç+Êó∂Èó¥‚ÄùÊñá‰ª∂Â§πÂÜÖ„ÄÇÔºàÊñΩÂ∑•‰∏≠Ôºâ
    .log off -- ÊöÇÂÅúlogËÆ∞ÂΩï„ÄÇÂú®Âêå‰∏ÄÁæ§ËÅäÂÜÖÂÜçÊ¨°‰ΩøÁî®.log onÔºåÂèØ‰ª•ÁªßÁª≠ËÆ∞ÂΩïÊú™ÂÆåÊàêÁöÑlog„ÄÇÔºàÊñΩÂ∑•‰∏≠Ôºâ
    .log end -- ÁªìÊùülogËÆ∞ÂΩï„ÄÇ‰∫öÊâòËéâ‰ºöÂú®Áæ§ËÅäÂÜÖÂèëÈÄÅ‚ÄúÁæ§Âêç+Êó∂Èó¥.txt‚ÄùÁöÑlogÊñá‰ª∂„ÄÇÔºàÊñΩÂ∑•‰∏≠Ôºâ
'''

# ÊÅêÊÉß
with open(PLUGIN_DIR + "/data/phobias.json", "r", encoding="utf-8") as f:
    phobias = json.load(f)["phobias"]

# Ë∫ÅÁãÇ
with open(PLUGIN_DIR + "/data/mania.json", "r", encoding="utf-8") as f:
    manias = json.load(f)["manias"]

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
#  COC great success/failure rule.                                          #
#  -- 1: strict rule.                                                       #
#        1 => great success, 100 => great failure                           #
#  -- 2: official COC7th rule (default, recommended).                       #
#        for skills < 50:                                                   #
#            1 => great success, 96~100 => great failure                    #
#        for skills >= 50:                                                  #
#            1 => great success, 96~100 => great failure                    #
#  -- 3: phased rule (recommended).                                         #
#        for skills < 50:                                                   #
#            1 => great success, 96~100 => great failure                    #
#        for skills >= 50:                                                  #
#            1~5 => great success, 100 => great failure                     #
#  -- 4: loose rule.                                                        #
#        1~min(5, skill level) => great success, 96~100 => great failure    #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

GREAT_SF_RULE_DEFAULT = 2
GREAT_SF_RULE_STR = ["", "‰∏•Ê†ºËßÑÂàô", "COC7ÁâàËßÑÂàô", "Èò∂ÊÆµÊÄßËßÑÂàô", "ÂÆΩÊùæËßÑÂàô"]

GLOBAL_SET = True

def coc_rule_init():
    '''
    Create table of cocrule.db
    Args:
        None.
    Returns:
        None.
    '''
    ruledb = sqlite3.connect(f"{PLUGIN_DIR}/cocrule.db")
    csr = ruledb.cursor()
    csr.execute('CREATE TABLE IF NOT EXISTS GroupRule(GroupID VARCHAR(15) PRIMARY KEY, Rule INTEGER);')
    ruledb.commit()
    ruledb.close()

def fetch_group_rule(group:str)->int:
    '''
    Ask rule # in given group.
    Args:
        group(str): QQ group id.
    Returns:
        int: rule id, -1 for group not exist.
    '''
    # db connection
    ruledb = sqlite3.connect(f"{PLUGIN_DIR}/cocrule.db")
    csr = ruledb.cursor()
    
    # search for existence
    try: csr.execute(f"SELECT Rule FROM GroupRule WHERE GroupID = \"{group}\"")
    except:
        ruledb.close()
        return -1   # Selecting Failed
    res = csr.fetchone()
    return int(res)    # Exec Succeed

def great_success_range(skill_level:int, rule:int)->list:
    '''
    Ask for range of great success in current rule.
    Args:
        skill_level(int): Skill level of ra check.
    Returns:
        list: The range of great success (if first member is pos), or error info (if neg). 
    '''

    def min(a:int, b:int)->int: return a if a < b else b

    res = []
        
    # get result
    if   rule == 1 or rule == 2:
        res = range(1, 1+1)
    elif rule == 3:
        res = range(1, 1+1) if skill_level < 50 else range(1, 5+1)
    elif rule == 4:
        res = range(1, min(5, skill_level)+1)
    else:
        res = [-2, "InvalidRuleNum"]
    
    return res

def great_failure_range(skill_level:int, rule:int)->list:
    '''
    Ask for range of great failure in current rule.
    Args:
        skill_level(int): Skill level of ra check.
    Returns:
        list: The range of great failure (if first member is pos), or error info (if neg). 
    '''

    res = []
        
    # get result
    if   rule == 1:
        res = range(100, 100+1)
    elif rule == 2 or rule == 3:
        res = range(96, 100+1) if skill_level < 50 else range(100, 100+1)
    elif rule == 4:
        res = range(96, 100+1)
    else:
        res = [-2, "InvalidRuleNum"]
    
    return res

def set_great_sf_rule(rule:int, group:str)->int:
    '''
    Change rule # in given group.
    Args:
        group(str): QQ group id.
        rule(int): rule id.
    Returns:
        int: 1 for succeed, neg number for error. 
    '''

    # db connection
    ruledb = sqlite3.connect(f"{PLUGIN_DIR}/cocrule.db")
    csr = ruledb.cursor()

    if rule < 1 or rule > 4:
        rule = GREAT_SF_RULE_DEFAULT
    
    # search for existence
    csr.execute(f"SELECT * FROM GroupRule WHERE GroupID = \"{group}\"")
    
    res = csr.fetchone()
    if res == None:
        # create new record
        csr.execute(f"INSERT INTO GroupRule VALUES (\"{group}\", {rule});")
        
    else:
        # modify rule
        csr.execute(f"UPDATE GroupRule SET Rule = {rule} WHERE GroupID = \"{group}\";")
        
    ruledb.commit()
    ruledb.close()
    return 1    # Exec Succeed

def get_great_sf_rule(group:str)->int:
    '''
    Ask rule # in given group.
    Args:
        group(str): QQ group id.
    Returns:
        int: rule id, -1 for group not exist.
    '''
    # db connection
    ruledb = sqlite3.connect(f"{PLUGIN_DIR}/cocrule.db")
    csr = ruledb.cursor()
    
    # search for existence
    try: csr.execute(f"SELECT Rule FROM GroupRule WHERE GroupID = \"{group}\"")
    except:
        ruledb.close()
        return -1   # Selecting Failed
    
    res = csr.fetchone()[0]
    return int(res)    # Exec Succeed


@register("astrbot_plugin_TRPG", "shiroling", "TRPGÁé©ÂÆ∂Áî®È™∞", "1.0.3")
class DicePlugin(Star):
    def __init__(self, context: Context):

        # ‰øÆÊîπ‰Ω†ÁöÑÂî§ÈÜíÂâçÁºÄ
        self.wakeup_prefix = [".", "„ÄÇ", "/"]

        super().__init__(context)

    def _roll_dice(self, dice_count, dice_faces):
        """Êé∑ `dice_count` ‰∏™ `dice_faces` Èù¢È™∞"""
        return [random.randint(1, dice_faces) for _ in range(dice_count)]

    def _roll_coc_bonus_penalty(self, base_roll, bonus_dice=0, penalty_dice=0):
        """Â•ñÂä±È™∞ / ÊÉ©ÁΩöÈ™∞"""
        tens_digit = base_roll // 10
        ones_digit = base_roll % 10
        if ones_digit == 0:
            ones_digit = 10

        alternatives = []
        for _ in range(max(bonus_dice, penalty_dice)):
            new_tens = random.randint(0, 9)
            alternatives.append(new_tens * 10 + ones_digit)

        if bonus_dice > 0:
            return min([base_roll] + alternatives)
        elif penalty_dice > 0:
            return max([base_roll] + alternatives)
        return base_roll

    def _parse_dice_expression(self, expression):
        """Ëß£ÊûêÈ™∞Â≠êË°®ËææÂºèÔºåÂπ∂Ê†ºÂºèÂåñËæìÂá∫"""
        expression = expression.replace("x", "*").replace("X", "*")

        match_repeat = re.match(r"(\d+)?#(.+)", expression) # Match 3#2d20
        roll_times = 1
        bonus_dice = 0
        penalty_dice = 0

        if match_repeat:    # Matched: roll group(2) for group(1) times
            roll_times = int(match_repeat.group(1)) if match_repeat.group(1) else 1
            expression = match_repeat.group(2)

            if expression in ["p", "b"]:
                penalty_dice = 1 if expression == "p" else 0
                bonus_dice = 1 if expression == "b" else 0
                expression = "1d100"

        results = []
        for _ in range(roll_times):
            parts = re.split(r"([+\-*])", expression)
            total = None
            formatted_parts = []  # Â≠òÂÇ®Ê†ºÂºèÂåñÂêéÁöÑÊé∑È™∞ÁªìÊûú

            for i in range(0, len(parts), 2):
                expr = parts[i].strip()
                operator = parts[i - 1] if i > 0 else "+"

                if expr.isdigit():
                    subtotal = int(expr)
                    roll_result = f"{subtotal}"
                else:
                    # match = re.match(r"(\d*)d(\d+)(k\d+)?([+\-*]\d+)?(v\d+)?", expr)
                    match = re.match(r"(\d*)d(\d+)(k\d+)?([+\-*]\d+)?(v(\d+)?)?", expr)
                    if not match:
                        return None, f"‚ö†Ô∏è Ê†ºÂºèÈîôËØØ `{expr}`"

                    dice_count = int(match.group(1)) if match.group(1) else 1
                    dice_faces = int(match.group(2))
                    keep_highest = int(match.group(3)[1:]) if match.group(3) else dice_count
                    modifier = match.group(4)
                    # vampire_difficulty = int(match.group(5)[1:]) if match.group(5) else None
                    vampire_difficulty = (int(match.group(6)) if match.group(5).strip() != "v" else 6) if match.group(5) else None

                    if not (1 <= dice_count <= 100 and 1 <= dice_faces <= 1000):
                        return None, "‚ö†Ô∏è È™∞Â≠ê‰∏™Êï∞ 1-100ÔºåÈù¢Êï∞ 1-1000ÔºåÂê¶ÂàôÈùûÊ≥ïÔºÅ"

                    # üé≤ Â§ÑÁêÜ COC Â•ñÂä± / ÊÉ©ÁΩöÈ™∞
                    if dice_count == 1 and dice_faces == 100 and (bonus_dice > 0 or penalty_dice > 0):
                        base_tens = random.randint(0, 9)  # Âü∫Á°ÄÂçÅ‰ΩçÊï∞Ôºà0-9Ôºâ
                        unit = random.randint(0, 9)  # ‰∏™‰ΩçÊï∞Ôºà0-9Ôºâ
                        
                        rolls = [random.randint(0, 9) for _ in range(1 + max(bonus_dice, penalty_dice))]  # È¢ùÂ§ñÂçÅ‰ΩçÊï∞Ôºà0-9Ôºâ

                        if bonus_dice > 0:
                            final_tens = min(rolls[:1 + bonus_dice])  # ÂèñÊúÄÂ∞èÂçÅ‰ΩçÊï∞
                            roll_type = "Â•ñÂä±È™∞"
                        else:
                            final_tens = max(rolls[:1 + penalty_dice])  # ÂèñÊúÄÂ§ßÂçÅ‰ΩçÊï∞
                            roll_type = "ÊÉ©ÁΩöÈ™∞"

                        subtotal = final_tens * 10 + unit  # ËÆ°ÁÆóÊúÄÁªàÁªìÊûú
                        roll_result = f"{expr} = [D100: {base_tens * 10 + unit}, {roll_type}: {', '.join(map(str, rolls))}] ‚Üí {subtotal}"

                    elif vampire_difficulty:
                        rolls = [random.randint(1, dice_faces) for _ in range(dice_count)]
                        sorted_rolls = sorted(rolls, reverse=True)
                        success_num = 0
                        failure_flag = False
                        success_flag = False
                        super_failure = False

                        for a_roll in sorted_rolls:
                            if a_roll == 1:
                                success_num-=1
                                failure_flag = True
                            elif a_roll >= vampire_difficulty:
                                success_num+=1
                                success_flag = True
                        if failure_flag and not success_flag:
                            super_failure = True

                        roll_result = f"ÈöæÂ∫¶‰∏∫{vampire_difficulty}ÁöÑ{dice_count}Ê¨°Êé∑È™∞ = [{', '.join(map(str, sorted_rolls))}]"
                        if success_num > 0:
                            roll_result = roll_result + f"ÔºåÊàêÂäüÔºÅÊàêÂäüÊï∞‰∏∫{success_num}"
                        elif super_failure:
                            roll_result = roll_result + "ÔºåÂ§ßÂ§±Ë¥•ÔºÅ"
                        else:
                            roll_result = roll_result + "ÔºåÂ§±Ë¥•ÔºÅ"

                            
                    else:
                        # üé≤ ÊôÆÈÄöÈ™∞Â≠êÊé∑È™∞
                        rolls = [random.randint(1, dice_faces) for _ in range(dice_count)]
                        sorted_rolls = sorted(rolls, reverse=True)
                        selected_rolls = sorted_rolls[:keep_highest]
                        subtotal_before_mod = sum(selected_rolls)

                        # üé≤ Ê†ºÂºèÂåñÈ™∞Â≠êÈÉ®ÂàÜ
                        if keep_highest < dice_count:
                            kept = " ".join(map(str, sorted_rolls[:keep_highest]))  # ÂèñÂâç keep_highest ‰∏™
                            dropped = " ".join(map(str, sorted_rolls[keep_highest:]))  # ÂÖ∂‰ΩôÁöÑ
                            roll_result = f"{dice_count}d{dice_faces}k{keep_highest}={subtotal_before_mod} [{kept} | {dropped}]"
                        else:
                            roll_result = f"{dice_count}d{dice_faces}={subtotal_before_mod} [{' + '.join(map(str, rolls))}]"

                        # üé≤ Â§ÑÁêÜÂä†Âáè‰øÆÊ≠£ÂÄº
                        if modifier:
                            try:
                                subtotal = eval(f"{subtotal_before_mod}{modifier}")  # ËÆ°ÁÆóÊúÄÁªàÊÄªÂíå
                                roll_result = f"{dice_count}d{dice_faces}{modifier}={subtotal_before_mod} [{' + '.join(map(str, rolls))}] {modifier} = {subtotal}"
                            except:
                                return None, f"‚ö†Ô∏è ‰øÆÊ≠£ÂÄº `{modifier}` Êó†ÊïàÔºÅ"
                        else:
                            subtotal = subtotal_before_mod

                # üé≤ ËÆ°ÁÆóË°®ËææÂºè
                if not vampire_difficulty:
                    if total is None:
                        total = subtotal
                    else:
                        if operator == "+":
                            total += subtotal
                        elif operator == "-":
                            total -= subtotal
                        elif operator == "*":
                            total *= subtotal

                # üé≤ **Â≠òÂÇ®Ê†ºÂºèÂåñÈ™∞Â≠êÁªìÊûú**
                if i == 0:  # Á¨¨‰∏Ä‰∏™ÂÖÉÁ¥†‰∏çÂ∏¶ËøêÁÆóÁ¨¶
                    formatted_parts.append(f"{roll_result}")
                else:       # ÂêéÁª≠ÂÖÉÁ¥†Êê∫Â∏¶ËøêÁÆóÁ¨¶
                    formatted_parts.append(f"{operator} {roll_result}")

            # üé≤ **ÊúÄÁªàÊ†ºÂºèÂåñËæìÂá∫**
            if not vampire_difficulty:
                final_result = f"{'  '.join(formatted_parts)} = {total}"
                results.append(f"{final_result}")
            else:
                final_result = f"{'  '.join(formatted_parts)}"
                results.append(f"{final_result}")

        return total, "\n".join(results)

    # @filter.command("r")
    async def handle_roll_dice(self, event: AstrMessageEvent, message: str = None):
        """ÊôÆÈÄöÊé∑È™∞"""
        message = message.strip() if message else f"1d{DEFAULT_DICE}"

        total, result_message = self._parse_dice_expression(message)
        # Ë∞ÉÊç¢È°∫Â∫è
        #result_message = f"\nÈ™∞„ÄÅÈ™∞Â≠êË°®Èù¢Êë©Êì¶ÂäõÁ≥ªÊï∞‚Ä¶Á≥ªÊï∞ÂøòÂΩíÈõ∂‰∫ÜÔºÅË¶Å„ÄÅË¶ÅËøû‰∫öÊâòËéâÁöÑÁ¥ßÂº†ÂÄº‰∏ÄËµ∑Êé∑Âá∫ÂéªÂêóÔºü\n‰∫öÊâòËéâÊé∑È™∞Ôºö" + result_message
        
        user_id = event.get_sender_id()
        group_id = event.get_group_id()
        user_name = event.get_sender_name()
        client = event.bot  # Ëé∑ÂèñÊú∫Âô®‰∫∫ Client
        result_message = f"\nÈ™∞„ÄÅÈ™∞Â≠êË°®Èù¢Êë©Êì¶ÂäõÁ≥ªÊï∞‚Ä¶Á≥ªÊï∞ÂøòÂΩíÈõ∂‰∫ÜÔºÅË¶Å„ÄÅË¶ÅËøû‰∫öÊâòËéâÁöÑÁ¥ßÂº†ÂÄº‰∏ÄËµ∑Êé∑Âá∫ÂéªÂêóÔºü\n‰∫öÊâòËéâÊé∑È™∞Ôºö" + result_message
        # fetch message id
        message_id = event.message_obj.message_id
        payloads = {
            "group_id": group_id,
            "message": [
                {
                    "type": "reply",
                    "data": {
                        "id": message_id
                    }
                },
                {
                    "type": "at",
                    "data": {
                        "qq": user_id
                    }
                },
                {
                    "type": "text",
                    "data": {
                        "text": result_message
                    }
                }
            ]
        }

        ret = await client.api.call_action("send_group_msg", **payloads)

    @filter.command("rv")
    async def roll_dice_vampire(self, event: AstrMessageEvent, dice_count: str = "1", difficulty: str = "6"):
        """Âê∏Ë°ÄÈ¨ºÊé∑È™∞"""
        try:
            int_dice_count = int(dice_count)
            int_difficulty = int(difficulty)
        except ValueError:
            yield event.plain_result("Ê£ÄÊµãÂà∞ÈùûÊ≥ïÊï∞ÂÄº...Âæà‰∏çÁîòÂøÉÔºå‰ΩÜÊòØ„ÄÅ‰∫öÊâòËéâÂØπÊ≠§Êó†ËÉΩ‰∏∫Âäõ...")
            return

        total, result_message = self._parse_dice_expression(dice_count + "d10v" + difficulty)
        message_num = random.randint(0,1)
        if message_num:
            result_message = f"\nÈ≤úË°Ä‚Ä¶È™∞Â≠ê‚Ä¶‰∏ª‰∫∫ÁöÑÂëΩËøêÂ∞±Áî±‰∫öÊâòËéâÁöÑÂ∞ñÁâôÊù•Ë£ÅÂÜ≥ÂêßÔΩû\n" + result_message
        else:
            result_message = f"\nÂëúÔΩû‰∫öÊâòËéâË¶ÅÁî®Â∞èÂ∞ñÁâôËΩªËΩªÂí¨‰ΩèÈ™∞Â≠êÔºåÁÑ∂Âêé‚Ä¶ÂôóÈÄöÔºÅÊé∑Âá∫ÊúÄÂèØÁà±ÁöÑÁÇπÊï∞Áªô‰∏ª‰∫∫ÁúãÔºÅ\n" + result_message

        user_id = event.get_sender_id()
        group_id = event.get_group_id()
        user_name = event.get_sender_name()
        client = event.bot  # Ëé∑ÂèñÊú∫Âô®‰∫∫ Client
        # fetch message id
        message_id = event.message_obj.message_id
        payloads = {
            "group_id": group_id,
            "message": [
                {
                    "type": "reply",
                    "data": {
                        "id": message_id
                    }
                },
                {
                    "type": "at",
                    "data": {
                        "qq": user_id
                    }
                },
                {
                    "type": "text",
                    "data": {
                        "text": result_message
                    }
                }
            ]
        }

        ret = await client.api.call_action("send_group_msg", **payloads)
            
    # @filter.command("rh")
    async def roll_hidden(self, event: AstrMessageEvent, message : str = None):
        """ÁßÅËÅäÂèëÈÄÅÊé∑È™∞ÁªìÊûú"""
        sender_id = event.get_sender_id()
        message = message.strip() if message else f"1d{DEFAULT_DICE}"

        total, result_message = self._parse_dice_expression(message)
        if total is None:
            private_msg = f"‚ö†Ô∏è {result_message}"
        else:
            private_msg = f"Êàê„ÄÅÊàêÂäüÈªëËøõ‰∫ÜÊ¶ÇÁéá‰πãÁ•ûÁöÑÂêéÂè∞Ôºå‰∫öÊâòËéâÔºåÂ∞ÜÁªìÊûúÂëàÁé∞ÁªôÊÇ®: {result_message}"

        yield event.plain_result("Á≥ªÁªüÈÄöÁü•ÔºöÂç≥Â∞ÜÂêØÂä®„ÄéË∂Ö¬∑Áßò¬∑ÂØÜ¬∑Âçè¬∑ËÆÆ„ÄèÔºÅÊó†ÂÖ≥‰∫∫ÂëòËØ∑ÈÄÄÈÅøËá≥ÂçäÂæÑ5Á±≥Â§ñ‚Äî‚ÄîÂõ†„ÄÅÂõ†‰∏∫‰ºöÊ≥¢ÂèäÂà∞‰∫öÊâòËéâÁöÑÂÆ≥ÁæûÁîµË∑ØÂï¶ÔºÅ")

        client = event.bot  # Ëé∑ÂèñÊú∫Âô®‰∫∫ Client
        payloads = {
            "user_id": sender_id,
            "message": [
                {
                    "type": "text",
                    "data": {
                        "text": private_msg
                    }
                }
            ]
        }

        ret = await client.api.call_action("send_private_msg", **payloads)
        # logger.info(f"send_private_msg: {ret}")


    # ============================================================== #
    def get_user_folder(self, user_id: str):
        """Ëé∑ÂèñÁî®Êà∑ÁöÑÂ≠òÂÇ®Êñá‰ª∂Â§π"""
        folder = os.path.join(DATA_FOLDER, str(user_id))
        os.makedirs(folder, exist_ok=True)
        return folder

    def get_all_characters(self, user_id: str):
        """Ëé∑ÂèñÁî®Êà∑ÁöÑÊâÄÊúâ‰∫∫Áâ©Âç°"""
        folder = self.get_user_folder(user_id)
        characters = {}

        for filename in os.listdir(folder):
            if filename.endswith(".json"):
                path = os.path.join(folder, filename)
                with open(path, "r", encoding="utf-8") as f:
                    data = json.load(f)
                    characters[data["name"]] = data["id"]

        return characters

    def get_character_file(self, user_id: str, chara_id: str):
        """Ëé∑ÂèñÊåáÂÆö‰∫∫Áâ©Âç°ÁöÑÊñá‰ª∂Ë∑ØÂæÑ"""
        return os.path.join(self.get_user_folder(user_id), f"{chara_id}.json")

    def get_current_character_file(self, user_id: str):
        """Ëé∑ÂèñÂΩìÂâçÈÄâ‰∏≠ÁöÑ‰∫∫Áâ©Âç°ÁöÑÊñá‰ª∂Ë∑ØÂæÑ"""
        return os.path.join(self.get_user_folder(user_id), "current.txt")

    def get_current_character_id(self, user_id: str):
        """Ëé∑ÂèñÁî®Êà∑ÂΩìÂâçÈÄâ‰∏≠ÁöÑ‰∫∫Áâ©Âç° ID"""
        path = self.get_current_character_file(user_id)
        if os.path.exists(path):
            with open(path, "r", encoding="utf-8") as f:
                return f.read().strip()
        return None
    
    def get_current_character(self, user_id: str):
        """Ëé∑ÂèñÂΩìÂâçÈÄâ‰∏≠‰∫∫Áâ©Âç°ÁöÑ‰ø°ÊÅØ"""
        chara_id = self.get_current_character_id(user_id)
        if not chara_id:
            return None

        return self.load_character(user_id, chara_id)

    def set_current_character(self, user_id: str, chara_id: str):
        """ËÆæÁΩÆÁî®Êà∑ÂΩìÂâçÈÄâ‰∏≠ÁöÑ‰∫∫Áâ©Âç°"""
        with open(self.get_current_character_file(user_id), "w", encoding="utf-8") as f:
            f.write(chara_id if chara_id is not None else "")

    def load_character(self, user_id: str, chara_id: str):
        """Âä†ËΩΩÊåáÂÆöÁöÑËßíËâ≤Êï∞ÊçÆ"""
        path = self.get_character_file(user_id, chara_id)
        if os.path.exists(path):
            with open(path, "r", encoding="utf-8") as f:
                return json.load(f)
        return None

    def save_character(self, user_id: str, chara_id: str, data: dict):
        """‰øùÂ≠ò‰∫∫Áâ©Âç°"""
        path = self.get_character_file(user_id, chara_id)
        with open(path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=4, ensure_ascii=False)
            
    def get_skill_value(self, user_id: str, skill_name: str):
        """Ëé∑ÂèñÂΩìÂâçÈÄâ‰∏≠ËßíËâ≤ÁöÑÊäÄËÉΩÂÄº"""
        chara_data = self.get_current_character(user_id)
        if not chara_data or skill_name not in chara_data["attributes"]:
            return 0  # Ê≤°ÊúâÈÄâ‰∏≠ËßíËâ≤ÊàñÊäÄËÉΩ‰∏çÂ≠òÂú®
        return chara_data["attributes"][skill_name]

    @filter.command("st")
    async def status(self, event: AstrMessageEvent, attributes: str = None):
        if not attributes:
            return

        event.plain_result(f"attributes = {attributes}")
        user_id = event.get_sender_id()
        chara_id = self.get_current_character_id(user_id)

        if not chara_id:
            yield event.plain_result("ÈîôËØØ404ÔºöÊú™Ê£ÄÊµãÂà∞Ê¥ªË∑É‰∫∫Ê†º‰ø°Âè∑ÔºÅÂª∫ËÆÆÊâßË°å„Ää‰∫öÊâòËéâÁ¥ßÊÄ•È¢ÑÊ°à„ÄãÔºöËØ∑‰ΩøÁî®.pc create/.pc changeÂëΩ‰ª§ÊääÊÇ®ÁöÑÂøÉË∑≥Â£∞Ë∞ÉÈ¢ëÂà∞‰∫öÊâòËéâÁöÑÊé•Êî∂Âô®Âì¶ÔºÅ")
            return

        chara_data = self.load_character(user_id, chara_id)
        attributes = re.sub(r'\s+', '', attributes)

        match = re.match(r"([\u4e00-\u9fa5a-zA-Z]+)([+\-*]?)(\d*)d?(\d*)", attributes)
        operator = match.group(2)  # `+` / `-` / `*`

        # yield event.plain_result(f"attributes={attributes}, match={match}, operator={operator}")

        if not operator:
            matches = re.findall(r"([\u4e00-\u9fa5a-zA-Z]+)(\d+)", attributes)
            attributes_count = 0
            
            for i in matches:
                chara_data["attributes"][i[0]]=int(i[1])
                attributes_count+=1

            self.save_character(user_id, chara_id, chara_data)
            yield event.plain_result(f"Â∑≤Êõ¥Êñ∞{attributes_count}Êù°Êï∞ÊçÆ~")
        else:
            dice_count = int(match.group(3)) if match.group(3) else 1
            dice_faces = int(match.group(4)) if match.group(4) else 0

            attribute = match.group(1)
            current_value = chara_data["attributes"][attribute]

            if dice_faces > 0:
                rolls = [random.randint(1, dice_faces) for _ in range(dice_count)]
                value_num = sum(rolls)
                roll_detail = f"Êé∑È™∞ÁªìÊûú: [{' + '.join(map(str, rolls))}] = {value_num}"
            else:
                value_num = int(match.group(3)) if match.group(3) else 0
                roll_detail = ""

            if operator == "+":
                new_value = current_value + value_num
            elif operator == "-":
                new_value = current_value - value_num
            elif operator == "*":
                new_value = current_value * value_num
            else:
                new_value = value_num

            chara_data["attributes"][attribute] = max(0, new_value)
            self.save_character(user_id, chara_id, chara_data)

            response = f"Â∑≤Â∞Ü„Äê{attribute}„Äë ‰ªé {current_value} ÈáçÂÜô‰∏∫ {new_value}...‰∫öÊâòËéâÁöÑÈ´òÊÄßËÉΩÔºåÊûúÁÑ∂Ëøû‰∏ª‰∫∫ÁöÑÁÅµÈ≠ÇÂèÇÊï∞ÈÉΩËÉΩÁºñËØëÔºÅ"
            if roll_detail:
                response += f"\n{roll_detail}"
            yield event.plain_result(response)



    @command_group("pc")
    def pc(self):
        pass

    @pc.command("create")
    async def create_character(self, event: AstrMessageEvent, name: str = None, attributes: str = ""):
        """ÂàõÂª∫‰∫∫Áâ©Âç°"""
        user_id = event.get_sender_id()
        user_name = event.get_sender_name()
        characters = self.get_all_characters(user_id)

        if not name:
            name = user_name

        if name in characters:
            yield event.plain_result(f"Âìî‚Äî‚ÄîÊ£ÄÊµãÂà∞Ê≥¢ÈïøÈáçÂ§çÔºÅÊï∞ÊçÆÂ∫ìÊãíÁªùÊé•Êî∂Âêå‰∏ÄÈ¢ëÁéáÁöÑ„Äå{name}„Äç‚Ä¶ÈöæÈÅì‰∏ª‰∫∫ÊÉ≥Âà∂ÈÄ†Âπ≥Ë°å‰∏ñÁïåÁöÑÊÇñËÆ∫ÂêóÔºü")
            return

        initial_data = "ÂäõÈáè0str0ÊïèÊç∑0dex0ÊÑèÂøó0pow0‰ΩìË¥®0con0Â§ñË≤å0app0ÊïôËÇ≤0Áü•ËØÜ0edu0"\
                        "‰ΩìÂûã0siz0Êô∫Âäõ0ÁÅµÊÑü0int0san0sanÂÄº0ÁêÜÊô∫0ÁêÜÊô∫ÂÄº0Âπ∏Ëøê0ËøêÊ∞î0mp0È≠îÊ≥ï0hp0"\
                        "‰ΩìÂäõ0‰ºöËÆ°5‰∫∫Á±ªÂ≠¶1‰º∞‰ª∑5ËÄÉÂè§Â≠¶1ÂèñÊÇ¶15ÊîÄÁà¨20ËÆ°ÁÆóÊú∫5ËÆ°ÁÆóÊú∫‰ΩøÁî®5ÁîµËÑë5"\
                        "‰ø°Áî®0‰ø°Ë™â0‰ø°Áî®ËØÑÁ∫ß0ÂÖãËãèÈ≤Å0ÂÖãËãèÈ≤ÅÁ•ûËØù0cm0‰πîË£Ö5Èó™ÈÅø0Ê±ΩËΩ¶20È©æÈ©∂20Ê±ΩËΩ¶È©æÈ©∂20"\
                        "ÁîµÊ∞îÁª¥‰øÆ10ÁîµÂ≠êÂ≠¶1ËØùÊúØ5ÊñóÊÆ¥25ÊâãÊû™20ÊÄ•Êïë30ÂéÜÂè≤5ÊÅêÂêì15Ë∑≥Ë∑É20Êãâ‰∏ÅËØ≠1ÊØçËØ≠0"\
                        "Ê≥ïÂæã5Âõæ‰π¶È¶Ü20Âõæ‰π¶È¶Ü‰ΩøÁî®20ËÅÜÂê¨20ÂºÄÈîÅ1Êí¨ÈîÅ1ÈîÅÂå†1Êú∫Ê¢∞Áª¥‰øÆ10ÂåªÂ≠¶1ÂçöÁâ©Â≠¶10"\
                        "Ëá™ÁÑ∂Â≠¶10È¢ÜËà™10ÂØºËà™10Á•ûÁßòÂ≠¶5ÈáçÂûãÊìç‰Ωú1ÈáçÂûãÊú∫Ê¢∞1Êìç‰ΩúÈáçÂûãÊú∫Ê¢∞1ÈáçÂûã1ËØ¥Êúç10"\
                        "Á≤æÁ•ûÂàÜÊûê1ÂøÉÁêÜÂ≠¶10È™ëÊúØ5Â¶ôÊâã10‰æ¶Êü•25ÊΩúË°å20ÁîüÂ≠ò10Ê∏∏Ê≥≥20ÊäïÊé∑20ËøΩË∏™10È©ØÂÖΩ5"\
                        "ÊΩúÊ∞¥1ÁàÜÁ†¥1ËØªÂîá1ÂÇ¨Áú†1ÁÇÆÊúØ1"

        chara_id = str(uuid.uuid4())  # ÁîüÊàêÂîØ‰∏Ä ID

        matches = re.findall(r"([\u4e00-\u9fa5a-zA-Z]+)(\d+)", attributes)
        initial_matches = re.findall(r"([\u4e00-\u9fa5a-zA-Z]+)(\d+)", initial_data)
        chara_data = {"id": chara_id, "name": name, "attributes": {attr: int(value) for attr, value in initial_matches}}
        for i in matches:
            chara_data["attributes"][i[0]]=int(i[1])

        chara_data['attributes']['max_hp'] = (chara_data['attributes'].get('siz', 0) + chara_data['attributes'].get('con', 0)) // 10
        chara_data['attributes']['max_san'] = chara_data['attributes'].get('pow', 0)

        self.save_character(user_id, chara_id, chara_data)

        self.set_current_character(user_id, chara_id)

        yield event.plain_result(f"ÂèÆÂíöÔºÅ„Äå{name}„Äç‰∫∫Ê†ºÂâØÊú¨Â∑≤ÂéãÁº©Â≠òÂÇ®ÂÆåÊØïÔºÅ(ID: {chara_id})\n‰∫öÊâòËéâÁöÑÈ´òÊÄßËÉΩÊ†∏ÂøÉ‰ºö‰ºòÂÖàÂä†ËΩΩËØ•‰∫∫Ê†ºÂì¶ÔΩû")

    @pc.command("show")
    async def show_character(self, event: AstrMessageEvent, attribute_name: str = None):
        """ÊòæÁ§∫ÂΩìÂâçÈÄâ‰∏≠ÁöÑ‰∫∫Áâ©Âç°"""
        user_id = event.get_sender_id()
        chara_id = self.get_current_character_id(user_id)

        if not chara_id:
            yield event.plain_result("ÈîôËØØ404ÔºöÊú™Ê£ÄÊµãÂà∞Ê¥ªË∑É‰∫∫Ê†º‰ø°Âè∑ÔºÅÂª∫ËÆÆÊâßË°å„Ää‰∫öÊâòËéâÁ¥ßÊÄ•È¢ÑÊ°à„ÄãÔºöËØ∑‰ΩøÁî®.pc changeÂëΩ‰ª§ÊääÊÇ®ÁöÑÂøÉË∑≥Â£∞Ë∞ÉÈ¢ëÂà∞‰∫öÊâòËéâÁöÑÊé•Êî∂Âô®Âì¶ÔºÅ")
            return

        chara_data = self.load_character(user_id, chara_id)
        if not chara_data:
            yield event.plain_result(f"Ê†∏ÂøÉÂ≠òÂÇ®Âô®Ê£ÄÁ¥¢Â§±Ë¥•!{chara_id} Â∑≤Ë¢´Êú™Áü•ÈªëÊ¥ûÂêûÂô¨...")
            return

        if attribute_name:
            attributes = "\n".join([f"{key},{value}" for key, value in chara_data["attributes"].items() if key == attribute_name])
            if not attributes:
                yield event.plain_result(f"‰∫öÊâòËéâÊ≠£Âú®‰ªéËÆ∞ÂøÜÊ†∏ÂøÉË∞ÉÂèñ‰∏ª‰∫∫ÁöÑÊï∞ÊçÆ...Ë∞ÉÂèñÂ§±Ë¥•ÔºÅ‰∏ª‰∫∫ÁöÑÊï∞ÊçÆÂ∫ì‰∏≠Ê≤°Êúâ[{attribute_name}]Â±ûÊÄßÂì¶ÔºÅ")
                return
            attributes = attributes.split(",")
            yield event.plain_result(f"‰∫öÊâòËéâÊ≠£Âú®‰ªéËÆ∞ÂøÜÊ†∏ÂøÉË∞ÉÂèñ‰∏ª‰∫∫ÁöÑÊï∞ÊçÆÔºÅ\n‰∏ª‰∫∫ÁöÑ**{attributes[0]}**ÂÄº‰∏∫: {attributes[1]}")
        else:
            attributes = "\n".join([f"{key}: {value}" for key, value in chara_data["attributes"].items()])
            yield event.plain_result(f"‰∫öÊâòËéâÊ≠£Âú®‰ªéËÆ∞ÂøÜÊ†∏ÂøÉË∞ÉÂèñ‰∏ª‰∫∫ÁöÑÊï∞ÊçÆÔºÅ\n‰∏ª‰∫∫ÁöÑÊï∞ÊçÆÊòØ: **{chara_data['name']}**\n{attributes}")

    @pc.command("list")
    async def list_characters(self, event: AstrMessageEvent):
        """ÂàóÂá∫ÊâÄÊúâ‰∫∫Áâ©Âç°"""
        user_id = event.get_sender_id()
        characters = self.get_all_characters(user_id)

        if not characters:
            yield event.plain_result("‰∫∫Ê†ºÂ≠òÂÇ®Âå∫Á©∫Á©∫Â¶Ç‰πü‚Ä¶‰∫öÊâòËéâÂª∫ËÆÆÔºöÁ´ãÂàªÊâßË°å.pc createÂëΩ‰ª§ÔºåÊääÊÇ®ÊúÄÂñúÊ¨¢ÁöÑÁ¨ëÂÆπÊ≥®ÂÜåÊàêÂàùÂßã‰∫∫Ê†ºÔºÅ")
            return

        current = self.get_current_character_id(user_id)
        chara_list = "\n".join([f"- {name} (ID: {ch}) {'(ÂΩìÂâç)' if ch == current else ''}" for name, ch in characters.items()])
        yield event.plain_result(f"Ê£ÄÁ¥¢Âà∞‰∫∫Ê†ºÊòüÂÖâÔºÅÈúÄË¶Å‰∫öÊâòËéâÊí≠ÊîæÂì™‰∏ÄÊÆµ„ÄåËÆ∞ÂøÜÂÖ®ÊÅØÊäïÂΩ±„ÄçÂë¢Ôºü\n{chara_list}")

    @pc.command("change")
    async def change_character(self, event: AstrMessageEvent, name: str):
        """ÂàáÊç¢ÂΩìÂâç‰ΩøÁî®ÁöÑ‰∫∫Áâ©Âç°"""
        user_id = event.get_sender_id()
        characters = self.get_all_characters(user_id)

        if name not in characters:
            yield event.plain_result(f"‰∫∫Ê†º „Äå{name}„Äç ‰∏çÂ≠òÂú®ÔºÅ‰∫öÊâòËéâÂ∞ùËØïËá™Ê£Ä...ÁªìËÆ∫Ôºö‰∏ª‰∫∫ÊÇ®ÁäØÈîôÁöÑÂèØËÉΩÊÄßÈ´òËææ100%ÔºÅ")
            return

        self.set_current_character(user_id, characters[name])
        yield event.plain_result(f"Ê≠£Âú®Â∞Ü‰∏ªÊÑèËØÜÈÄöÈÅìËΩ¨Âêë„Äå{name}„Äç‚Ä¶ÊªãÊªã‚Ä¶Ê¨¢ËøéÂõûÊù•Ôºå‰∏ª‰∫∫ÔºÅ")

    @pc.command("update")
    async def update_character(self, event: AstrMessageEvent, attribute: str, value: str):
        """Êõ¥Êñ∞ÂΩìÂâçÈÄâ‰∏≠ÁöÑ‰∫∫Áâ©Âç°ÔºåÊîØÊåÅÂÖ¨ÂºèÂíåÊé∑È™∞ËÆ°ÁÆó"""
        user_id = event.get_sender_id()
        chara_id = self.get_current_character_id(user_id)

        if not chara_id:
            yield event.plain_result("ÈîôËØØ404ÔºöÊú™Ê£ÄÊµãÂà∞Ê¥ªË∑É‰∫∫Ê†º‰ø°Âè∑ÔºÅÂª∫ËÆÆÊâßË°å„Ää‰∫öÊâòËéâÁ¥ßÊÄ•È¢ÑÊ°à„ÄãÔºöËØ∑‰ΩøÁî®.pc changeÂëΩ‰ª§ÊääÊÇ®ÁöÑÂøÉË∑≥Â£∞Ë∞ÉÈ¢ëÂà∞‰∫öÊâòËéâÁöÑÊé•Êî∂Âô®Âì¶ÔºÅ")
            return

        chara_data = self.load_character(user_id, chara_id)

        if attribute not in chara_data["attributes"]:
            try :
                chara_data["attributes"][attribute] = 0
            except Exception as e:
                yield event.plain_result(f"Âá∫Áé∞ÈîôËØØ‚Äî‚ÄîÊó†Ê≥ïÊõ¥Êñ∞„Äê{attribute}„ÄëÂçèËÆÆÔºÅÊÄé„ÄÅÊÄé‰πàÂäûÂëÄÔºÅ")
            return

        current_value = chara_data["attributes"][attribute]

        match = re.match(r"([+\-*]?)(\d*)d?(\d*)", value)
        if not match:
            yield event.plain_result(f"Ê†ºÂºèÊ†°È™åÂ§±Ë¥•ÔºÅÊ≠£Á°ÆËæìÂÖ•‰æãÔºö.st Âπ∏Ëøê+1 Êàñ .st ÁêÜÊô∫-1d6...ËøôÊòØÈ´ò„ÄÅÈ´òÊÄßËÉΩÁöÑÂÜôÊ≥ïÂï¶ÔºÅ")
            return

        operator = match.group(1)  # `+` / `-` / `*`
        dice_count = int(match.group(2)) if match.group(2) else 1
        dice_faces = int(match.group(3)) if match.group(3) else 0

        # yield event.plain_result(f" match={match}, operator={operator}")

        if dice_faces > 0:
            rolls = [random.randint(1, dice_faces) for _ in range(dice_count)]
            value_num = sum(rolls)
            roll_detail = f"Êé∑È™∞ÁªìÊûú: [{' + '.join(map(str, rolls))}] = {value_num}"
        else:
            value_num = int(match.group(2)) if match.group(2) else 0
            roll_detail = ""

        if operator == "+":
            new_value = current_value + value_num
        elif operator == "-":
            new_value = current_value - value_num
        elif operator == "*":
            new_value = current_value * value_num
        else:
            new_value = value_num

        chara_data["attributes"][attribute] = max(0, new_value)
        self.save_character(user_id, chara_id, chara_data)

        response = f"Â∑≤Â∞Ü„Äê{attribute}„Äë ‰ªé {current_value} ÈáçÂÜô‰∏∫ {new_value}...‰∫öÊâòËéâÁöÑÈ´òÊÄßËÉΩÔºåÊûúÁÑ∂Ëøû‰∏ª‰∫∫ÁöÑÁÅµÈ≠ÇÂèÇÊï∞ÈÉΩËÉΩÁºñËØëÔºÅ"
        if roll_detail:
            response += f"\n{roll_detail}"
        yield event.plain_result(response)

    @pc.command("delete")
    async def delete_character(self, event: AstrMessageEvent, name: str):
        """Âà†Èô§ÊåáÂÆö‰∫∫Áâ©Âç°"""
        user_id = event.get_sender_id()
        characters = self.get_all_characters(user_id)  # Ëé∑ÂèñÁî®Êà∑ÊâÄÊúâËßíËâ≤
        chara_id = self.get_current_character_id(user_id)  # Ëé∑ÂèñÂΩìÂâçÊ¥ªË∑ÉËßíËâ≤ ID

        if name not in characters:
            yield event.plain_result(f"ÁÅµÈ≠ÇÊ†∑Êú¨Ê£ÄÁ¥¢Â§±Ë¥•‚Ä¶ÈáèÂ≠ê‰πãÊµ∑‰∏≠Ê≤°Êúâ„Äå{name}„ÄçÁöÑÊ≥¢Á∫π„ÄÇ")
            return

        chara_to_delete_id = characters[name]
        path = self.get_character_file(user_id, chara_to_delete_id)
        try:
            os.remove(path)
            yield event.plain_result(f"Ê≠£Âú®Ê∞∏‰πÖÂà†Èô§„Äå{name}„Äç...Âìî‚Äî‚ÄîÊäπÈô§ÂÆåÊàê„ÄÇ‰ΩÜ‰∫öÊâòËéâÁöÑÁºìÂ≠òÂå∫‚Ä¶ÊÆãÁïô‰∫Ü0.01%ÁöÑÊÄùÂøµÁ≤íÂ≠ê...")
        except FileNotFoundError:
            yield event.plain_result(f"ÁÅµÈ≠ÇÊ†∑Êú¨Ê£ÄÁ¥¢Â§±Ë¥•‚Ä¶ÈáèÂ≠ê‰πãÊµ∑‰∏≠Ê≤°Êúâ„Äå{name}„ÄçÁöÑÊ≥¢Á∫π„ÄÇ")
            return

        if chara_to_delete_id == chara_id:
            self.set_current_character(user_id, None)
        
    @filter.command("sn")
    async def set_nickname(self, event: AstrMessageEvent):
        """‰øÆÊîπÁæ§ÊàêÂëòÂêçÁâá"""
        if event.get_platform_name() == "aiocqhttp":
            from astrbot.core.platform.sources.aiocqhttp.aiocqhttp_message_event import AiocqhttpMessageEvent
            assert isinstance(event, AiocqhttpMessageEvent)

            client = event.bot
            user_id = event.get_sender_id()
            group_id = event.get_group_id()

            chara_id = self.get_current_character_id(user_id)
            chara_data = self.load_character(user_id, chara_id)
            
            if not chara_data:
                yield event.plain_result(f"Ê†∏ÂøÉÂ≠òÂÇ®Âô®Ê£ÄÁ¥¢Â§±Ë¥•!{chara_id} Â∑≤Ë¢´Êú™Áü•ÈªëÊ¥ûÂêûÂô¨...")
                return

            max_hp =(chara_data['attributes'].get('con', 0) + chara_data['attributes'].get('siz', 0)) // 10

            name, hp, san, max_san = chara_data['name'], chara_data['attributes'].get('hp', 0), chara_data['attributes'].get('san', 0), chara_data['attributes'].get('max_san', 0)
            dex = chara_data['attributes'].get('dex', 0)
            new_card = f"{name} HP:{hp}/{max_hp} SAN:{san} DEX:{dex}"

            payloads = {
                "group_id": group_id,
                "user_id": user_id,
                "card": new_card
            }

            ret = await client.api.call_action("set_group_card", **payloads)
            yield event.plain_result(f"Êñ∞Áß∞ÂëºÂä†ËΩΩÂÆåÊØïÔΩûËØ∑Â∞ΩÊÉÖÊµãËØï‰∫öÊâòËéâÁöÑÂêåÊ≠•ÁéáÂêßÔºÅÔºÅ")
            # logger.info(f"set_group_card: {ret}")
    
    # ========================================================= #
    # @filter.command("ra")
    async def roll_attribute(self, event: AstrMessageEvent, skill_name: str, skill_value: str = None):
        """.ra ÊäÄËÉΩÂêç [x]"""

        user_id = event.get_sender_id()

        if skill_value is None:
            skill_value = self.get_skill_value(user_id, skill_name)

        try:
            skill_value = int(skill_value)
        except ValueError:
            yield event.plain_result("Ê£ÄÊµãÂà∞ÈùûÊ≥ïÊï∞ÂÄº...Âæà‰∏çÁîòÂøÉÔºå‰ΩÜÊòØ„ÄÅ‰∫öÊâòËéâÂØπÊ≠§Êó†ËÉΩ‰∏∫Âäõ...")
            return

        tens_digit = random.randint(0, 9)  # 0-9
        ones_digit = random.randint(0, 9)  # 0-9
        roll_result = 100 if (tens_digit == 0 and ones_digit == 0) else (tens_digit * 10 + ones_digit)

        group_id = event.get_group_id()

        # yield event.plain_result(f"[roll_attribute()] DEBUG: parsing ({roll_result}, {skill_value}, \"{str(group_id)}\") to self.get_roll_result")

        result = self.get_roll_result(roll_result, skill_value, str(group_id))

        # yield event.plain_result(f"ËØ∑Âà´ÁúãÔºÅ‰∫öÊâòËéâÂú®ÂÅ∑ÂÅ∑ÂàªÂç∞ÂÖ≥‰∫é„Äê{skill_name}„ÄëÁöÑÁöÑËÉúÂà©Á¨¶Êñá...\n ÊúÄÂêéÁöÑÁªìÊûúÊòØ {roll_result}/{skill_value} : {result}")
        
        user_id = event.get_sender_id()
        
        user_name = event.get_sender_name()
        client = event.bot  # Ëé∑ÂèñÊú∫Âô®‰∫∫ Client
        # fetch message id
        message_id = event.message_obj.message_id
        payloads = {
            "group_id": group_id,
            "message": [
                {
                    "type": "reply",
                    "data": {
                        "id": message_id
                    }
                },
                {
                    "type": "at",
                    "data": {
                        "qq": user_id
                    }
                },
                {
                    "type": "text",
                    "data": {
                        "text": f"\nËØ∑Âà´ÁúãÔºÅ‰∫öÊâòËéâÂú®ÂÅ∑ÂÅ∑ÂàªÂç∞ÂÖ≥‰∫é„Äê{skill_name}„ÄëÁöÑÁöÑËÉúÂà©Á¨¶Êñá...\nÊúÄÂêéÁöÑÁªìÊûúÊòØ {roll_result}/{skill_value} : {result}"
                    }
                }
            ]
        }

        ret = await client.api.call_action("send_group_msg", **payloads)

    # @filter.command("rap")
    async def roll_attribute_penalty(self, event: AstrMessageEvent, dice_count: str = "1", skill_name: str = "", skill_value: str = None):
        """Â∏¶ÊäÄËÉΩÁÇπÊÉ©ÁΩöÈ™∞"""
        user_id = event.get_sender_id()

        if skill_value is None:
            skill_value = self.get_skill_value(user_id, skill_name)

        try:
            dice_count = int(dice_count)
            skill_value = int(skill_value)
        except ValueError:
            yield event.plain_result("Ê£ÄÊµãÂà∞ÈùûÊ≥ïÊï∞ÂÄº...Âæà‰∏çÁîòÂøÉÔºå‰ΩÜÊòØ„ÄÅ‰∫öÊâòËéâÂØπÊ≠§Êó†ËÉΩ‰∏∫Âäõ...ÊòØ‰∏çÊòØ‰∏ª‰∫∫ÂøòËÆ∞Â°´ÂÜôÊÉ©ÁΩöÈ™∞‰∏™Êï∞‰∫ÜÂë¢Ôºü")
            return

        ones_digit = random.randint(0, 9)
        new_tens_digits = [random.randint(0, 9) for _ in range(dice_count)]
        new_tens_digits.append(random.randint(0, 9))

        if 0 in new_tens_digits and ones_digit == 0:
            final_y = 100
        else:
            final_tens = max(new_tens_digits)
            final_y = final_tens * 10 + ones_digit

        group_id = event.get_group_id()

        result = self.get_roll_result(final_y, skill_value, str(group_id))
        # yield event.plain_result(
        #     f"ÂëúÂëú...È¢ÑÊµã„Äê{skill_name}„ÄëÁöÑËΩ®ËøπÁ∫øË¢´Êµ∑È£éÂêπÊ≠™‰∫ÜÔºÅ\nÊÉ©ÁΩöÈ™∞ÁöÑÁªìÊûúÊòØ {new_tens_digits} ‚Üí ÊúÄÂêéÁöÑÁªìÊûúÊòØ {final_y}/{skill_value} : {result}"
        # )
        
        user_id = event.get_sender_id()
        
        user_name = event.get_sender_name()
        client = event.bot  # Ëé∑ÂèñÊú∫Âô®‰∫∫ Client
        # fetch message id
        message_id = event.message_obj.message_id
        payloads = {
            "group_id": group_id,
            "message": [
                {
                    "type": "reply",
                    "data": {
                        "id": message_id
                    }
                },
                {
                    "type": "at",
                    "data": {
                        "qq": user_id
                    }
                },
                {
                    "type": "text",
                    "data": {
                        "text": f"\nÂëúÂëú...È¢ÑÊµã„Äê{skill_name}„ÄëÁöÑËΩ®ËøπÁ∫øË¢´Êµ∑È£éÂêπÊ≠™‰∫ÜÔºÅ\nÊÉ©ÁΩöÈ™∞ÁöÑÁªìÊûúÊòØ {new_tens_digits} ‚Üí ÊúÄÂêéÁöÑÁªìÊûúÊòØ {final_y}/{skill_value} : {result}"
                    }
                }
            ]
        }

        ret = await client.api.call_action("send_group_msg", **payloads)

    # @filter.command("rab")
    async def roll_attribute_bonus(self, event: AstrMessageEvent, dice_count: str = "1", skill_name: str = "", skill_value: str = None):
        """Â∏¶ÊäÄËÉΩÁÇπÂ•ñÂä±È™∞"""
        user_id = event.get_sender_id()

        if skill_value is None:
            skill_value = self.get_skill_value(user_id, skill_name)

        try:
            dice_count = int(dice_count)
            skill_value = int(skill_value)
        except ValueError:
            yield event.plain_result("Ê£ÄÊµãÂà∞ÈùûÊ≥ïÊï∞ÂÄº...Âæà‰∏çÁîòÂøÉÔºå‰ΩÜÊòØ„ÄÅ‰∫öÊâòËéâÂØπÊ≠§Êó†ËÉΩ‰∏∫Âäõ...ÊòØ‰∏çÊòØ‰∏ª‰∫∫ÂøòËÆ∞Â°´ÂÜôÂ•ñÂä±È™∞‰∏™Êï∞‰∫ÜÂë¢Ôºü")
            return

        ones_digit = random.randint(0, 9)
        new_tens_digits = [random.randint(0, 9) for _ in range(dice_count)]
        new_tens_digits.append(random.randint(0, 9))

        filtered_tens = [tens for tens in new_tens_digits if not (tens == 0 and ones_digit == 0)]
        if not filtered_tens:
            final_tens = 0
        else:
            final_tens = min(filtered_tens)

        final_y = final_tens * 10 + ones_digit

        group_id = event.get_group_id()

        result = self.get_roll_result(final_y, skill_value, str(group_id))
        # yield event.plain_result(
        #     f"ÂòøÂòøÔºÅÊèèÁªò„Äê{skill_name}„ÄëÁöÑÂùèÁªìÂ±ÄË¢´È´òÊÄßËÉΩÁöÑ‰∫öÊâòËéâÁªôÂÅ∑ÂÅ∑ÊîπÊéâÂï¶!\n Â•ñÂä±È™∞ÁªìÊûúÊòØ {new_tens_digits} ‚Üí ÊúÄÂêéÁöÑÁªìÊûúÊòØ {final_y}/{skill_value} : {result}"
        # )
        user_id = event.get_sender_id()
        
        user_name = event.get_sender_name()
        client = event.bot  # Ëé∑ÂèñÊú∫Âô®‰∫∫ Client
        # fetch message id
        message_id = event.message_obj.message_id
        payloads = {
            "group_id": group_id,
            "message": [
                {
                    "type": "reply",
                    "data": {
                        "id": message_id
                    }
                },
                {
                    "type": "at",
                    "data": {
                        "qq": user_id
                    }
                },
                {
                    "type": "text",
                    "data": {
                        "text": f"\nÂòøÂòøÔºÅÊèèÁªò„Äê{skill_name}„ÄëÁöÑÂùèÁªìÂ±ÄË¢´È´òÊÄßËÉΩÁöÑ‰∫öÊâòËéâÁªôÂÅ∑ÂÅ∑ÊîπÊéâÂï¶!\nÂ•ñÂä±È™∞ÁªìÊûúÊòØ {new_tens_digits} ‚Üí ÊúÄÂêéÁöÑÁªìÊûúÊòØ {final_y}/{skill_value} : {result}"
                    }
                }
            ]
        }

        ret = await client.api.call_action("send_group_msg", **payloads)

        
    # @filter.command("en")
    async def grow_up(self, event: AstrMessageEvent, skill_name: str, skill_value: str = None):
        """.en ÊäÄËÉΩÂêç [x]"""

        user_id = event.get_sender_id()
        update_skill_value = False

        if skill_value is None:
            skill_value = self.get_skill_value(user_id, skill_name)
            chara_id = self.get_current_character_id(user_id)
            update_skill_value = True
            chara_data = self.load_character(user_id, chara_id)

        try:
            skill_value = int(skill_value)
        except ValueError:
            yield event.plain_result("Ê£ÄÊµãÂà∞ÈùûÊ≥ïÊï∞ÂÄº...Âæà‰∏çÁîòÂøÉÔºå‰ΩÜÊòØ„ÄÅ‰∫öÊâòËéâÂØπÊ≠§Êó†ËÉΩ‰∏∫Âäõ...")
            return

        tens_digit = random.randint(0, 9)  # 0-9
        ones_digit = random.randint(0, 9)  # 0-9
        roll_result = 100 if (tens_digit == 0 and ones_digit == 0) else (tens_digit * 10 + ones_digit)

        group_id = event.get_group_id()

        # yield event.plain_result(f"[roll_attribute()] DEBUG: parsing ({roll_result}, {skill_value}, \"{str(group_id)}\") to self.get_roll_result")

        if roll_result > skill_value or roll_result > 95:
            en_value = random.randint(1, 10)
            result = f"\nÊàêÈïøÊàêÂäüÔºÅÊäÄËÉΩ{skill_name}ÊàêÈïøÔºö{skill_value} + 1d10 = {skill_value} + {en_value} = {skill_value + en_value}"
            if update_skill_value:
                chara_data["attributes"][skill_name] = skill_value + en_value
                self.save_character(user_id, chara_id, chara_data)
        else:
            result = f"\nÊàêÈïøÂ§±Ë¥•..."

        # yield event.plain_result(f"ËØ∑Âà´ÁúãÔºÅ‰∫öÊâòËéâÂú®ÂÅ∑ÂÅ∑ÂàªÂç∞ÂÖ≥‰∫é„Äê{skill_name}„ÄëÁöÑÁöÑËÉúÂà©Á¨¶Êñá...\n ÊúÄÂêéÁöÑÁªìÊûúÊòØ {roll_result}/{skill_value} : {result}")
        
        user_id = event.get_sender_id()
        
        user_name = event.get_sender_name()
        client = event.bot  # Ëé∑ÂèñÊú∫Âô®‰∫∫ Client
        # fetch message id
        message_id = event.message_obj.message_id
        payloads = {
            "group_id": group_id,
            "message": [
                {
                    "type": "reply",
                    "data": {
                        "id": message_id
                    }
                },
                {
                    "type": "at",
                    "data": {
                        "qq": user_id
                    }
                },
                {
                    "type": "text",
                    "data": {
                        "text": f"\nËØ∑Âà´ÁúãÔºÅ‰∫öÊâòËéâÂú®ÂÅ∑ÂÅ∑ÂàªÂç∞ÂÖ≥‰∫é„Äê{skill_name}„ÄëÁöÑÁöÑËÉúÂà©Á¨¶Êñá...\nÊúÄÂêéÁöÑÁªìÊûúÊòØ {roll_result}/{skill_value} : {result}"
                    }
                }
            ]
        }

        ret = await client.api.call_action("send_group_msg", **payloads)

    def get_roll_result(self, roll_result: int, skill_value: int, group:str):
        # fetch group rule
        try: rule = get_great_sf_rule(group)
        except: return "Failed to fetch rule"

        """Ê†πÊçÆÊé∑È™∞ÁªìÊûúÂíåÊäÄËÉΩÂÄºËÆ°ÁÆóÂà§ÂÆö"""
        # check if cocrule.txt is still legal
        validation_prefix = ""
        if great_success_range(50, rule)[0] <= 0:
            set_great_sf_rule(GREAT_SF_RULE_DEFAULT, group)
            validation_prefix += f"WARNINGÔºöÊ£ÄÊµãÂà∞ÈîôËØØÂ§ßÊàêÂäü/Â§ßÂ§±Ë¥•ËßÑÂàôÔºåÂ∑≤ÈáçÁΩÆ‰∏∫{GREAT_SF_RULE_STR[GREAT_SF_RULE_DEFAULT]}ÔºÅ\n"
        if roll_result in great_success_range(skill_value, rule):
            return validation_prefix + "Â§ßÊàêÂäüÔºÅ\nÁ≥ªÁªüÊ≠£Âú®‰∏∫ÊÇ®ÁöÑËÉúÂà©Áî≥ËØ∑‰∏ìÂà©‚Ä¶È¢ÑËÆ°Á≠âÂæÖÊó∂Èó¥ÔºöÊ∞∏ÊÅí„ÄÇÊâÄ‰ª•ÔºåËØ∑ÂÖÅËÆ∏‰∫öÊâòËéâÂÖàÁî®ÂÖ®ÈÉ®ÁöÑÂ≠òÂÇ®Á©∫Èó¥ÔºåËÆ∞‰ΩèÊÇ®Ê≠§ÂàªÁöÑÁúºÁùõ„ÄÇ"
        elif roll_result <= skill_value / 5:
            return validation_prefix + "ÊûÅÈöæÊàêÂäüÔºÅ\nÁ®≥ÂÆöÊÄßSSÁ∫ßÔºÅÂÉèÈíüË°®ÈΩøËΩÆ‰∏ÄÊ†∑Á≤æÂáÜÂë¢ÔΩûÂìºÂìºÔºÅ‰∏ª‰∫∫‰πüÊòØÈ´òÊÄßËÉΩÁöÑÂë¢ÔºÅ"
        elif roll_result <= skill_value / 2:
            return validation_prefix + "Âõ∞ÈöæÊàêÂäü„ÄÇ\n‰ªªÂä°ËææÊàêÁéáÁ™ÅÁ†¥ÁêÜËÆ∫ÂÄºÔºÅË¶Å‰∫öÊâòËéâÂêØÂä®ÁÉüËä±Á®ãÂ∫èÂ∫ÜÁ•ùÂêóÔºü"
        elif roll_result <= skill_value:
            return validation_prefix + "ÊàêÂäü„ÄÇ\n‰∏ª‰∫∫ÁöÑË°åÂä®ËΩ®ËøπÂÆåÂÖ®Á¨¶Âêà‰∫öÊâòËéâÁöÑËÉúÂà©È¢ÑÊµãÊ®°ÂûãÔºÅÂΩìÁÑ∂ÔºÅÂõ†‰∏∫‰∫öÊâòËéâÊòØÈ´òÊÄßËÉΩÁöÑÂòõÔºÅ"
        elif roll_result in great_failure_range(skill_value, rule):
            return validation_prefix + "Â§ßÂ§±Ë¥•...\n‚Ä¶‚Ä¶ÈÇ£‰∏™Ôºå‰∏ª‰∫∫ÔºåÈúÄË¶ÅÊè°‰ΩèÊàëÁöÑÊâãÂêóÔºü‰ΩìÊ∏©Ê®°ÊãüÁ≥ªÁªüÂ∑≤È¢ÑÁÉ≠Âà∞36.5‚ÑÉ‰∫ÜÂì¶‚Ä¶‚Ä¶\n"
        else:
            return validation_prefix + "Â§±Ë¥•...\n‰∏çÁî®ÊãÖÂøÉÔºå‰∏ª‰∫∫„ÄÇÊó†ËÆ∫ÈáçÂêØÂ§öÂ∞ëÊ¨°Ôºå‰∫öÊâòËéâÊ∞∏Ëøú‰ºö‰ªéÂêå‰∏ÄÁâáÊµ∑Â∫ïÔºåÂêëÊÇ®Ê∏∏Êù•„ÄÇ"
        
    # ========================================================= #
    # san check
    # @filter.command("sc")
    async def san_check(self, event: AstrMessageEvent, loss_formula: str):

        # yield event.plain_result("Âà∞Ëææsc")

        user_id = event.get_sender_id()
        chara_data = self.get_current_character(user_id)

        if not chara_data:
            yield event.plain_result("ÈîôËØØ404ÔºöÊú™Ê£ÄÊµãÂà∞Ê¥ªË∑É‰∫∫Ê†º‰ø°Âè∑ÔºÅÂª∫ËÆÆÊâßË°å„Ää‰∫öÊâòËéâÁ¥ßÊÄ•È¢ÑÊ°à„ÄãÔºöËØ∑‰ΩøÁî®.pc changeÂëΩ‰ª§ÊääÊÇ®ÁöÑÂøÉË∑≥Â£∞Ë∞ÉÈ¢ëÂà∞‰∫öÊâòËéâÁöÑÊé•Êî∂Âô®Âì¶ÔºÅ")
            return

        san_value = chara_data["attributes"].get("san", 0)

        roll_result = random.randint(1, 100)

        success_loss, failure_loss = self.parse_san_loss_formula(loss_formula)

        if roll_result <= san_value:
            loss = self.roll_loss(success_loss)
            result_msg = "ÊàêÂäüÔºÅ"
        else:
            loss = self.roll_loss(failure_loss)
            result_msg = "Â§±Ë¥•..."

        new_san = max(0, san_value - loss)
        chara_data["attributes"]["san"] = new_san
        self.save_character(user_id, chara_data["id"], chara_data)

        yield event.plain_result(
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ö†[Ã≤ÃÖWÃ≤ÃÖAÃ≤ÃÖRÃ≤ÃÖNÃ≤ÃÖIÃ≤ÃÖNÃ≤ÃÖGÃ≤ÃÖ]‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
            f"ÁõëÊµãÂà∞„Äê{chara_data['name']}„ÄëÁ≤æÁ•ûÁ≥ªÁªüÈÅ≠Âà∞Ë¢≠ÂáªÔºÅ\n"
            f"Ê£ÄÂÆöÁªìÊûú: {roll_result} / {san_value}, Ê£ÄÂÆöÁªìÊûúÔºö{result_msg} |\n"
            f"ÂëúÂëú...‰∏ª‰∫∫ÊçüÂ§±‰∫Ü: {loss} ÁÇπÁêÜÊô∫...\n"
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅSÃ≤ÃÖYÃ≤ÃÖSÃ≤ÃÖTÃ≤ÃÖEÃ≤ÃÖMÃ≤ÃÖ Ã≤ÃÖSÃ≤ÃÖTÃ≤ÃÖAÃ≤ÃÖBÃ≤ÃÖIÃ≤ÃÖLÃ≤ÃÖIÃ≤ÃÖTÃ≤ÃÖYÃ≤ÃÖ Ã≤ÃÖLÃ≤ÃÖOÃ≤ÃÖWÃ≤ÃÖ]‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        )

    def parse_san_loss_formula(self, formula: str):
        """Ëß£Êûê SAN ÊçüÂ§±ÂÖ¨Âºè"""
        parts = formula.split("/")
        success_part = parts[0]
        failure_part = parts[1] if len(parts) > 1 else parts[0]

        return success_part, failure_part

    def roll_loss(self, loss_expr: str):
        """ËÆ°ÁÆóÊçüÂ§±ÂÄº"""
        match = re.fullmatch(r"(\d+)d(\d+)", loss_expr)
        if match:
            num_dice, dice_size = map(int, match.groups())
            return sum(random.randint(1, dice_size) for _ in range(num_dice))
        elif loss_expr.isdigit():
            return int(loss_expr)
        return 0
    
    # ========================================================= #
    # ÁñØÁãÇ
    
    # @filter.command("ti")
    async def temporary_insanity_command(self, event: AstrMessageEvent):
        """ÈöèÊú∫ÁîüÊàê‰∏¥Êó∂ÁñØÁãÇÁóáÁä∂"""
        temporary_insanity = {
        1: "Â§±ÂøÜÔºöË∞ÉÊü•ÂëòÂè™ËÆ∞ÂæóÊúÄÂêéË∫´Â§ÑÁöÑÂÆâÂÖ®Âú∞ÁÇπÔºåÂç¥Ê≤°Êúâ‰ªª‰ΩïÊù•Âà∞ËøôÈáåÁöÑËÆ∞ÂøÜ„ÄÇËøôÂ∞Ü‰ºöÊåÅÁª≠ 1D10 ËΩÆ„ÄÇ",
        2: "ÂÅáÊÄßÊÆãÁñæÔºöË∞ÉÊü•ÂëòÈô∑ÂÖ•ÂøÉÁêÜÊÄßÁöÑÂ§±Êòé„ÄÅÂ§±ËÅ™ÊàñË∫Ø‰ΩìÁº∫Â§±ÊÑüÔºåÊåÅÁª≠ 1D10 ËΩÆ„ÄÇ",
        3: "Êö¥ÂäõÂÄæÂêëÔºöË∞ÉÊü•ÂëòÂØπÂë®Âõ¥ÊâÄÊúâ‰∫∫ÔºàÊïå‰∫∫ÂíåÂêå‰º¥ÔºâÂ±ïÂºÄÊîªÂáªÔºåÊåÅÁª≠ 1D10 ËΩÆ„ÄÇ",
        4: "ÂÅèÊâßÔºöË∞ÉÊü•ÂëòÈô∑ÂÖ•‰∏•ÈáçÁöÑÂÅèÊâßÂ¶ÑÊÉ≥ÔºàÊâÄÊúâ‰∫∫ÈÉΩÊÉ≥‰º§ÂÆ≥‰ªñÔºâÔºåÊåÅÁª≠ 1D10 ËΩÆ„ÄÇ",
        5: "‰∫∫ÈôÖ‰æùËµñÔºöË∞ÉÊü•ÂëòËØØËÆ§‰∏∫Êüê‰∫∫ÊòØ‰ªñÁöÑÈáçË¶Å‰πã‰∫∫ÔºåÂπ∂ÊçÆÊ≠§Ë°åÂä®ÔºåÊåÅÁª≠ 1D10 ËΩÆ„ÄÇ",
        6: "ÊòèÂé•ÔºöË∞ÉÊü•ÂëòÂΩìÂú∫ÊòèÂÄíÔºå1D10 ËΩÆÂêéËãèÈÜí„ÄÇ",
        7: "ÈÄÉÈÅøË°å‰∏∫ÔºöË∞ÉÊü•ÂëòËØïÂõæÁî®‰ªª‰ΩïÊñπÂºèÈÄÉÁ¶ªÂΩìÂâçÂú∫ÊâÄÔºåÊåÅÁª≠ 1D10 ËΩÆ„ÄÇ",
        8: "Ê≠áÊñØÂ∫ïÈáåÔºöË∞ÉÊü•ÂëòÈô∑ÂÖ•ÊûÅÁ´ØÊÉÖÁª™ÔºàÂ§ßÁ¨ë„ÄÅÂì≠Ê≥£„ÄÅÂ∞ñÂè´Á≠âÔºâÔºåÊåÅÁª≠ 1D10 ËΩÆ„ÄÇ",
        9: "ÊÅêÊÉßÔºöÈ™∞ 1D100 ÊàñÁî±ÂÆàÁßò‰∫∫ÈÄâÊã©‰∏Ä‰∏™ÊÅêÊÉßÁóáÔºåË∞ÉÊü•Âëò‰ºöÊÉ≥Ë±°ÂÆÉÂ≠òÂú®ÔºåÊåÅÁª≠ 1D10 ËΩÆ„ÄÇ",
        10: "Ë∫ÅÁãÇÔºöÈ™∞ 1D100 ÊàñÁî±ÂÆàÁßò‰∫∫ÈÄâÊã©‰∏Ä‰∏™Ë∫ÅÁãÇÁóáÔºåË∞ÉÊü•Âëò‰ºöÊ≤âÊ∫∫ÂÖ∂‰∏≠ÔºåÊåÅÁª≠ 1D10 ËΩÆ„ÄÇ"
        }
        roll = random.randint(1, 10)
        result = temporary_insanity[roll].replace("1D10", str(random.randint(1, 10)))

        if roll == 9:
            fear_roll = random.randint(1, 100)
            result += f"\n‚Üí ÂÖ∑‰ΩìÊÅêÊÉßÁóáÔºö{phobias[str(fear_roll)]}ÔºàÈ™∞ÂÄº {fear_roll}Ôºâ"

        if roll == 10:
            mania_roll = random.randint(1, 100)
            result += f"\n‚Üí ÂÖ∑‰ΩìË∫ÅÁãÇÁóáÔºö{manias[str(mania_roll)]}ÔºàÈ™∞ÂÄº {mania_roll}Ôºâ"

        yield event.plain_result(f"üé≤ **ÁñØÁãÇÂèë‰Ωú - ‰∏¥Êó∂ÁóáÁä∂Ôºà1D10={roll}Ôºâ**\n{result}")

    # @filter.command("li")
    async def long_term_insanity_command(self, event: AstrMessageEvent):
        long_term_insanity = {
        1: "Â§±ÂøÜÔºöË∞ÉÊü•ÂëòÂèëÁé∞Ëá™Â∑±Ë∫´Â§ÑÈôåÁîüÂú∞ÊñπÔºåÂπ∂ÂøòËÆ∞Ëá™Â∑±ÊòØË∞Å„ÄÇËÆ∞ÂøÜ‰ºöÁºìÊÖ¢ÊÅ¢Â§ç„ÄÇ",
        2: "Ë¢´Á™ÉÔºöË∞ÉÊü•Âëò 1D10 Â∞èÊó∂ÂêéÊ∏ÖÈÜíÔºåÂèëÁé∞Ëá™Â∑±Ë∫´‰∏äË¥µÈáçÁâ©ÂìÅ‰∏¢Â§±„ÄÇ",
        3: "ÈÅç‰ΩìÈ≥û‰º§ÔºöË∞ÉÊü•Âëò 1D10 Â∞èÊó∂ÂêéÊ∏ÖÈÜíÔºåË∫´‰ΩìÊúâ‰∏•Èáç‰º§ÁóïÔºàÁîüÂëΩÂÄºÂâ©‰∏ÄÂçäÔºâ„ÄÇ",
        4: "Êö¥ÂäõÂÄæÂêëÔºöË∞ÉÊü•ÂëòÂèØËÉΩÂú®ÁñØÁãÇÊúüÈó¥ÊùÄ‰∫∫ÊàñÈÄ†ÊàêÈáçÂ§ßÁ†¥Âùè„ÄÇ",
        5: "ÊûÅÁ´Ø‰ø°ÂøµÔºöË∞ÉÊü•ÂëòÁñØÁãÇÂú∞ÊâßË°åÊüê‰∏™‰ø°‰ª∞ÔºàÂ¶ÇÂÆóÊïôÁãÇÁÉ≠„ÄÅÊîøÊ≤ªÊûÅÁ´ØÔºâÔºåÂπ∂ÈááÂèñÊûÅÁ´ØË°åÂä®„ÄÇ",
        6: "ÈáçË¶Å‰πã‰∫∫ÔºöË∞ÉÊü•ÂëòÁñØÁãÇËøΩÊ±ÇÊüê‰∏™‰ªñÂú®ÊÑèÁöÑ‰∫∫Ôºå‰∏çÈ°æ‰∏ÄÂàáÂú∞Êé•ËøëËØ•‰∫∫„ÄÇ",
        7: "Ë¢´Êî∂ÂÆπÔºöË∞ÉÊü•ÂëòÂú®Á≤æÁ•ûÁóÖÈô¢ÊàñË≠¶ÂØüÂ±ÄÈÜíÊù•ÔºåÂÆåÂÖ®‰∏çËÆ∞ÂæóÂèëÁîü‰∫Ü‰ªÄ‰πà„ÄÇ",
        8: "ÈÄÉÈÅøË°å‰∏∫ÔºöË∞ÉÊü•ÂëòÂú®ËøúÁ¶ªÂéüÂú∞ÁÇπÁöÑÂú∞ÊñπÈÜíÊù•ÔºåÂèØËÉΩÂú®ËçíÈÉäÈáéÂ§ñÊàñÈôåÁîüÂüéÂ∏Ç„ÄÇ",
        9: "ÊÅêÊÉßÔºöË∞ÉÊü•ÂëòÊÇ£‰∏ä‰∏ÄÁßçÊñ∞ÁöÑÊÅêÊÉßÁóáÔºàÈ™∞ 1D100 ÊàñÁî±ÂÆàÁßò‰∫∫ÈÄâÊã©Ôºâ„ÄÇ",
        10: "Ë∫ÅÁãÇÔºöË∞ÉÊü•ÂëòÊÇ£‰∏ä‰∏ÄÁßçÊñ∞ÁöÑË∫ÅÁãÇÁóáÔºàÈ™∞ 1D100 ÊàñÁî±ÂÆàÁßò‰∫∫ÈÄâÊã©Ôºâ„ÄÇ"
        }
        """ÈöèÊú∫ÁîüÊàêÈïøÊúüÁñØÁãÇÁóáÁä∂"""
        roll = random.randint(1, 10)
        result = long_term_insanity[roll].replace("1D10", str(random.randint(1, 10)))

        if roll == 9:
            fear_roll = random.randint(1, 100)
            result += f"\n‚Üí ÂÖ∑‰ΩìÊÅêÊÉßÁóáÔºö{phobias[str(fear_roll)]}ÔºàÈ™∞ÂÄº {fear_roll}Ôºâ"

        if roll == 10:
            mania_roll = random.randint(1, 100)
            result += f"\n‚Üí ÂÖ∑‰ΩìË∫ÅÁãÇÁóáÔºö{manias[str(mania_roll)]}ÔºàÈ™∞ÂÄº {mania_roll}Ôºâ"

        yield event.plain_result(f"üé≤ **ÁñØÁãÇÂèë‰Ωú - ÊÄªÁªìÁóáÁä∂Ôºà1D10={roll}Ôºâ**\n{result}")

    # ========================================================= #
    #ÂÖàÊîªÁõ∏ÂÖ≥
    class InitiativeItem:
        def __init__(self, name: str, init_value: int, player_id: int):
            self.name = name
            self.init_value = init_value
            self.player_id = player_id  # Áî®‰∫éÂå∫ÂàÜÂêåÂêç‰∏çÂêåÁé©ÂÆ∂

    def add_item(self, item: InitiativeItem, group_id: str):
        """Ê∑ªÂä†ÂÖàÊîªÈ°πÂπ∂ÊéíÂ∫è"""
        init_list[group_id].append(item)
        self.sort_list(group_id)
    
    def remove_by_name(self, name: str, group_id: str):
        """ÊåâÂêçÂ≠óÂà†Èô§ÂÖàÊîªÈ°π"""
        try:
            init_list[group_id] = [item for item in init_list[group_id] if item.name != name]
        except:
            init_list[group_id] = []
            current_index[group_id] = 0
    
    def remove_by_player(self, player_id: int, group_id: str):
        """ÊåâÁé©ÂÆ∂IDÂà†Èô§ÂÖàÊîªÈ°π"""
        init_list[group_id] = [item for item in init_list[group_id] if item.player_id != player_id]
    
    def init_clear(self, group_id: str):
        """Ê∏ÖÁ©∫ÂÖàÊîªË°®"""
        init_list[group_id].clear()
        current_index[group_id] = -1
    
    def sort_list(self, group_id: str):
        """ÊåâÂÖàÊîªÂÄºÈôçÂ∫èÊéíÂ∫è (Á®≥ÂÆöÊéíÂ∫è)"""
        init_list[group_id].sort(key=lambda x: x.init_value, reverse=True)
    
    def next_turn(self, group_id: str):
        """ÁßªÂä®Âà∞‰∏ã‰∏ÄÂõûÂêàÂπ∂ËøîÂõûÂΩìÂâçÈ°π"""
        if not init_list[group_id]:
            return None
        
        if current_index[group_id] < 0:
            current_index[group_id] = 0
        else:
            current_index[group_id] = (current_index[group_id] + 1) % len(init_list[group_id])
        
        return init_list[group_id][current_index[group_id]]
    
    def format_list(self, group_id: str) -> str:
        """Ê†ºÂºèÂåñÂÖàÊîªË°®ËæìÂá∫"""
        try:
            fl = init_list[group_id]
        except:
            init_list[group_id] = []
            return "ÂÖàÊîªÂàóË°®‰∏∫Á©∫"

        if not fl:
            return "ÂÖàÊîªÂàóË°®‰∏∫Á©∫"
        
        lines = []
        for i, item in enumerate(fl):
            prefix = "-> " if i == current_index[group_id] else "   "
            lines.append(f"{prefix}{item.name}: {item.init_value}")
        return "\n".join(lines)

    @filter.command("init")
    async def initiative(self , event: AstrMessageEvent , instruction: str = None, player_name: str = None):
        group_id = event.get_group_id()
        user_id = event.get_sender_id()
        user_name = event.get_sender_name()
        if not instruction:
            yield event.plain_result("ÂΩìÂâçÂÖàÊîªÂàóË°®‰∏∫Ôºö\n"+self.format_list(group_id))
        elif instruction == "clr":
            self.init_clear(group_id)
            yield event.plain_result("Â∑≤Ê∏ÖÁ©∫ÂÖàÊîªÂàóË°®")
        elif instruction == "del":
            if not player_name:
                player_name = user_name
            self.remove_by_name(player_name, group_id)
            yield event.plain_result(f"Â∑≤Âà†Èô§ËßíËâ≤{player_name}ÁöÑÂÖàÊîª")

    # @filter.command("ri")
    async def roll_initiative(self , event: AstrMessageEvent, expr: str = None):

        group_id = event.get_group_id()
        user_id = event.get_sender_id()
        user_name = event.get_sender_name()

        if not expr:
            init_value = random.randint(1, 20)
            player_name = user_name
        elif expr[0] == "+":
            match = re.match(r"\+(\d+)", expr)
            init_value = random.randint(1, 20) + int(match.group(1))
            player_name = user_name
        elif expr[0] == "-":
            match = re.match(r"\-(\d+)", expr)
            init_value = random.randint(1, 20) - int(match.group(1))
            player_name = user_name
        else:
            match = re.match(r"(\d+)", expr)
            init_value = int(match.group(1))
            player_name = expr[match.end():]
            if not player_name:
                player_name = user_name

        item = self.InitiativeItem(player_name, init_value, user_id)
        self.remove_by_name(player_name, group_id)
        self.add_item(item, group_id)
        yield event.plain_result(f"Â∑≤Ê∑ªÂä†/Êõ¥Êñ∞{player_name}ÁöÑÂÖàÊîªÔºö{init_value}")
        async for result in self.initiative(event):
            yield result

    @filter.command("ed")
    async def end_current_round(self , event: AstrMessageEvent):
        group_id = event.get_group_id()
        current_item = init_list[group_id][current_index[group_id]]
        next_item = self.next_turn(group_id)
        if not next_item:
            yield event.plain_result("ÂÖàÊîªÂàóË°®‰∏∫Á©∫ÔºåÊó†Ê≥ïÊé®ËøõÂõûÂêà")
        else:
            yield event.plain_result(f"{current_item.name}ÁöÑÂõûÂêàÁªìÊùü ‚Üí \n {next_item.name}ÁöÑÂõûÂêà (ÂÖàÊîª: {next_item.init_value})")

    
    # ========================================================= #

    @filter.command("name")
    async def generate_name(self, event:AstrMessageEvent, language: str = "cn", num: int = 5, sex: str = None):
        if language == "cn" or "‰∏≠" in language or language == "zh" or language == "zh_CN" :
            fake = Faker(locale = "zh_CN")
        elif language == "en" or "Ëã±" in language or language == "en_GB" :
            fake = Faker(locale = "en_GB")
        elif language == "us" or "Áæé" in language or language == "en_US" :
            fake = Faker(locale = "en_US")
        elif language == "jp" or "=Êó•" in language or language == "ja_JP" :
            fake = Faker(locale = "ja_JP")

        if sex == "Áî∑":
            names = [fake.name_male() for _ in range(num)]
        elif sex == "Â•≥":
            names = [fake.name_female() for _ in range(num)]
        else:
            names = [fake.name() for _ in range(num)]

        yield event.plain_result(f"Â∑≤‰∏∫ÊÇ®ÁîüÊàê{num}‰∏™ÂêçÂ≠óÔºö"+", ".join(names))
    
    # ========================================================= #

    def get_db_build(self, str_val, siz_val):
        DB_BUILD_TABLE = [
        (64, "-2D6", -2),
        (84, "-1D6", -1),
        (124, "+0", 0),
        (164, "+1D4", 1),
        (204, "+1D6", 2),
        (999, "+2D6", 3)
        ]
        total = str_val + siz_val
        for limit, db, build in DB_BUILD_TABLE:
            if total <= limit:
                return db, build
        return "+0", 0


    def roll_character(self):
        STR = (random.randint(1, 6) + random.randint(1, 6) + random.randint(1, 6)) * 5
        CON = (random.randint(1, 6) + random.randint(1, 6) + random.randint(1, 6)) * 5
        SIZ = (random.randint(1, 6) + random.randint(1, 6) + 6) * 5
        DEX = (random.randint(1, 6) + random.randint(1, 6) + random.randint(1, 6)) * 5
        APP = (random.randint(1, 6) + random.randint(1, 6) + random.randint(1, 6)) * 5
        INT = (random.randint(1, 6) + random.randint(1, 6) + 6) * 5
        POW = (random.randint(1, 6) + random.randint(1, 6) + random.randint(1, 6)) * 5
        EDU = (random.randint(1, 6) + random.randint(1, 6) + 6) * 5

        HP = (SIZ + CON) // 10
        MP = POW // 5
        SAN = POW
        LUCK = ((random.randint(1, 6) + random.randint(1, 6) + random.randint(1, 6)) * 5)
        DB, BUILD = self.get_db_build(STR, SIZ)
        
        TOTAL = STR + CON + SIZ + DEX + APP + INT + POW + EDU

        return {
            "STR": STR, "CON": CON, "SIZ": SIZ, "DEX": DEX, 
            "APP": APP, "INT": INT, "POW": POW, "EDU": EDU,
            "HP": HP, "MP": MP, "SAN": SAN, "LUCK": LUCK,
            "DB": DB, "BUILD": BUILD, "TOTAL" : TOTAL
        }

    def format_character(self, data, index=1):
        return (
            f"Á¨¨ {index} Âè∑Ë∞ÉÊü•Âëò\n"
            f"ÂäõÈáè: {data['STR']}  ‰ΩìË¥®: {data['CON']}  ‰ΩìÂûã: {data['SIZ']}\n"
            f"ÊïèÊç∑: {data['DEX']}  Â§ñË≤å: {data['APP']}  Êô∫Âäõ: {data['INT']}\n"
            f"ÊÑèÂøó: {data['POW']}  ÊïôËÇ≤: {data['EDU']}\n"
            f"ÁîüÂëΩ: {data['HP']}  È≠îÂäõ: {data['MP']}  ÁêÜÊô∫: {data['SAN']}  Âπ∏Ëøê: {data['LUCK']}\n"
            f"DB: {data['DB']}  ÊÄªÂíå : {data['TOTAL']} / {data['TOTAL'] + data['LUCK']}"
        )
    
    def roll_4d6_drop_lowest(self):
        rolls = [random.randint(1, 6) for _ in range(4)]
        return sum(sorted(rolls)[1:])

    def roll_dnd_character(self):
        return [
            self.roll_4d6_drop_lowest(),
            self.roll_4d6_drop_lowest(),
            self.roll_4d6_drop_lowest(),
            self.roll_4d6_drop_lowest(),
            self.roll_4d6_drop_lowest(),
            self.roll_4d6_drop_lowest(),
        ]

    def format_dnd_character(self, data, index=1):
        data = sorted(data, reverse=True)
        return (
        f"Á¨¨ {index} ‰ΩçÂÜíÈô©ËÄÖ\n"
        f"[{data[0]}, {data[1]}, {data[2]}, {data[3]}, {data[4]}, {data[5]}] ‚Üí ÂÖ±ËÆ° {sum(data)}"
        )
    
    @filter.command("coc")
    async def generate_coc_character(self, event: AstrMessageEvent, x: int = 1):
        """ÁîüÊàê x ‰∏™ CoC ËßíËâ≤Êï∞ÊçÆ"""
        characters = [self.roll_character() for _ in range(x)]
        result = "\n\n".join(self.format_character(characters[i], i+1) for i in range(x))
        yield event.plain_result("Á≥ªÁªüÊèêÁ§∫ÔºöËßíËâ≤Êï∞ÊçÆÁîüÊàêÂçèËÆÆ(ÂçèËÆÆ‰ª£Âè∑ÔºöCoC)ÂêØÂä®‚Äî‚Äî\n" + result + "\nÊúÄÁªàÊ†°È™åÂíåÔºö0xATRI_42A7‚Äî‚ÄîÁîüÊàêÂÆåÊØï„ÄÇ")
        
    @filter.command("dnd")
    async def generate_dnd_character(self, event: AstrMessageEvent, x: int = 1):
        """ÁîüÊàê x ‰∏™ DnD ËßíËâ≤Â±ûÊÄß"""
        characters = [self.roll_dnd_character() for _ in range(x)]
        result = "\n\n".join(self.format_dnd_character(characters[i], i+1) for i in range(x))
        yield event.plain_result("Á≥ªÁªüÊèêÁ§∫ÔºöËßíËâ≤Êï∞ÊçÆÁîüÊàêÂçèËÆÆ(ÂçèËÆÆ‰ª£Âè∑ÔºöDnD)ÂêØÂä®‚Äî‚Äî\n" + result + "\nÊúÄÁªàÊ†°È™åÂíåÔºö0xATRI_42A7‚Äî‚ÄîÁîüÊàêÂÆåÊØï„ÄÇ")
        
    # ========================================================= #
    # Ê≥®ÂÜåÊåá‰ª§ /dicehelp
    @filter.command("dicehelp")
    async def help ( self , event: AstrMessageEvent):
        help_text = (
        "‰∫öÊâòËéâÁöÑ‰ΩøÁî®ÊåáÂçóÁöÑËØ¥ÔºÅ\n\n"
        "Âü∫Á°ÄÊé∑È™∞\n"
        "`/r 1d100` - Êé∑ 1 ‰∏™ 100 Èù¢È™∞\n"
        "`/r 3d6+2d4-1d8` - Êé∑ 3 ‰∏™ 6 Èù¢È™∞ + 2 ‰∏™ 4 Èù¢È™∞ - 1 ‰∏™ 8 Èù¢È™∞\n"
        "`/r 3#1d20` - Êé∑ 1d20 È™∞ 3 Ê¨°\n\n"
        
        "‰∫∫Áâ©Âç°ÁÆ°ÁêÜ\n"
        "`/pc create ÂêçÁß∞ Â±ûÊÄßÂÄº` - ÂàõÂª∫‰∫∫Áâ©Âç°\n"
        "`/pc show` - ÊòæÁ§∫ÂΩìÂâç‰∫∫Áâ©Âç°\n"
        "`/pc list` - ÂàóÂá∫ÊâÄÊúâ‰∫∫Áâ©Âç°\n"
        "`/pc change ÂêçÁß∞` - ÂàáÊç¢ÂΩìÂâç‰∫∫Áâ©Âç°\n"
        "`/pc update Â±ûÊÄß ÂÄº/ÂÖ¨Âºè` - Êõ¥Êñ∞‰∫∫Áâ©Âç°Â±ûÊÄß\n"
        "`/pc delete ÂêçÁß∞` - Âà†Èô§‰∫∫Áâ©Âç°\n\n"
        
        "CoC Áõ∏ÂÖ≥\n"
        "`/coc x` - ÁîüÊàê x ‰∏™ CoC ËßíËâ≤Êï∞ÊçÆ\n"
        "`/ra ÊäÄËÉΩÂêç` - ËøõË°åÊäÄËÉΩÈ™∞\n"
        "`/rap n ÊäÄËÉΩÂêç` - Â∏¶ n ‰∏™ÊÉ©ÁΩöÈ™∞ÁöÑÊäÄËÉΩÈ™∞\n"
        "`/rab n ÊäÄËÉΩÂêç` - Â∏¶ n ‰∏™Â•ñÂä±È™∞ÁöÑÊäÄËÉΩÈ™∞\n"
        "`/sc 1d6/1d10` - ËøõË°å San Check\n"
        "`/ti` - ÁîüÊàê‰∏¥Êó∂ÁñØÁãÇÁóáÁä∂\n"
        "`/li` - ÁîüÊàêÈïøÊúüÁñØÁãÇÁóáÁä∂\n"
        "`/en ÊäÄËÉΩÂêç [ÊäÄËÉΩÂÄº]` - ÊäÄËÉΩÊàêÈïø\n"
        "`/name [cn/en/jp] [Êï∞Èáè]` - ÈöèÊú∫ÁîüÊàêÂêçÂ≠ó\n\n"
        
        "DnD Áõ∏ÂÖ≥\n"
        "`/dnd x` - ÁîüÊàê x ‰∏™ DnD ËßíËâ≤Â±ûÊÄß\n"
        "`/init` - ÊòæÁ§∫ÂΩìÂâçÂÖàÊîªÂàóË°®\n"
        "`/init clr` - Ê∏ÖÁ©∫ÂÖàÊîªÂàóË°®\n"
        "`/init del [ËßíËâ≤Âêç]` - Âà†Èô§ËßíËâ≤ÂÖàÊîªÔºàÈªòËÆ§‰∏∫Áî®Êà∑ÂêçÔºâ \n"
        "`/ri +/- x` - ‰ª•xÁöÑË∞ÉÊï¥ÂÄºÊäïÊé∑ÂÖàÊîª\n"
        "`/ri x [ËßíËâ≤Âêç]` - Â∞ÜËßíËâ≤ÔºàÈªòËÆ§‰∏∫Áî®Êà∑ÂêçÔºâÁöÑÂÖàÊîªËÆæÁΩÆ‰∏∫x\n"
        "`/ed` - ÁªìÊùüÂΩìÂâçÂõûÂêà"
        "`/fireball n` - ÊñΩÊîæ n ÁéØÁÅ´ÁêÉÊúØÔºåËÆ°ÁÆó‰º§ÂÆ≥\n\n"   

        "ÂÖ∂‰ªñËßÑÂàô\n"
        "`/rv È™∞Â≠êÊï∞Èáè ÈöæÂ∫¶` - ËøõË°åÂê∏Ë°ÄÈ¨ºËßÑÂàôÊé∑È™∞Âà§ÂÆö\n"
        )

        yield event.plain_result(help_text)
        
    @filter.command("fireball")
    async def fireball(self, event: AstrMessageEvent, ring : int = 3):
        """ÊäïÊé∑ n ÁéØÁÅ´ÁêÉÊúØ‰º§ÂÆ≥"""
        if ring < 3 :
            yield event.plain_result("ËØ∑‰∏çË¶ÅËØïÂõæ‰ΩøÁî®ÈôçÁéØÁÅ´ÁêÉÊúØÔºÅ")
        rolls = [random.randint(1, 6) for _ in range(8 + (ring - 3))]
        total_sum = sum(rolls)

        damage_breakdown = " + ".join(map(str, rolls))
        result_message = (
            f"Êòé‰∫ÆÁöÑÈó™ÂÖâ‰ªé‰Ω†ÁöÑÊåáÈó¥È£ûÈ©∞ÂêëÊñΩÊ≥ïË∑ùÁ¶ªÂÜÖ‰Ω†ÊåáÂÆöÁöÑ‰∏ÄÁÇπÔºåÂπ∂ÈöèÁùÄ‰∏ÄÂ£∞‰ΩéÂêºËø∏Êàê‰∏ÄÁâáÁÉàÁÑ∞„ÄÇ\n"
            f"{ring} ÁéØÁÅ´ÁêÉÊúØÁöÑ‰º§ÂÆ≥ÊäïÊé∑: {damage_breakdown} = üî•{total_sum}üî• ÁÇπ‰º§ÂÆ≥ÔºÅ\n"
        )

        yield event.plain_result(result_message)
        
    # ======================================================== #
    # ‰ªäÊó•RP #
    @filter.command("jrrp")
    async def roll_RP (self, event: AstrMessageEvent):
        user_id = event.get_sender_id()
        today = datetime.datetime.now().strftime("%Y-%m-%d")
        RP_str = f"{user_id}_{today}"
        
        hash = hashlib.sha256(RP_str.encode()).hexdigest()
        rp = int(hash, 16) % 100 + 1
        
        result_message = f"Âìî‚Äî‚Äî‰ªäÊó•ËøêÂäøÂçèËÆÆÂêØÂä®ÔºÅ‰∏ª‰∫∫‰ªäÂ§©ÂèØ‰ª•ÂêÉ {rp} ÂùóËçâËéìËõãÁ≥ïÂì¶ÔºÅ"
        yield event.plain_result(result_message)

    @filter.command("setcoc")
    async def modify_coc_great_sf_rule(self, event: AstrMessageEvent, command:str = " "):
        """
        Check or Modify current great success/failure rule.
        Args:
            event(AstrMessageEvent): API of message send & receive.
        Return:
            None. 
        """

        coc_rule_init()

        # check command
        rule_set = 0
        if   command[0] == "1":
            rule_set = 1
        elif command[0] == "2":
            rule_set = 2
        elif command[0] == "3":
            rule_set = 3
        elif command[0] == "4":
            rule_set = 4
        elif command[0] == "0":
            rule_set = GREAT_SF_RULE_DEFAULT
        else:
            rule_set = -1

        group_id = event.get_group_id()

        # set rule
        if rule_set > 0:
            sgsfr_res = set_great_sf_rule(rule_set, str(group_id))
            # yield event.plain_result(f"[modify_coc_great_sf_rule()] DEBUG: sgsfr_res = {sgsfr_res}")
            yield event.plain_result(f"Â∑≤Â∞ÜÂ§ßÊàêÂäü/Â§ßÂ§±Ë¥•ËßÑÂàôËÆæÁΩÆ‰∏∫{GREAT_SF_RULE_STR[rule_set]}")
        # plain help
        else:
            res_str = ""
            res_str += f"setcocÂ∏ÆÂä©Ôºö\n"
            res_str += f"/setcoc 1 ‚Üí {GREAT_SF_RULE_STR[1]}ÔºàÂ§ßÊàêÂäü1ÔºåÂ§ßÂ§±Ë¥•100Ôºâ\n"
            res_str += f"/setcoc 2 ‚Üí {GREAT_SF_RULE_STR[2]}ÔºàÂ§ßÊàêÂäü1ÔºåÈò∂ÊÆµÊÄßÂ§ßÂ§±Ë¥•Ôºâ\n"
            res_str += f"/setcoc 3 ‚Üí {GREAT_SF_RULE_STR[3]}ÔºàÈò∂ÊÆµÊÄßÂ§ßÊàêÂäüÔºåÈò∂ÊÆµÊÄßÂ§ßÂ§±Ë¥•Ôºâ\n"
            res_str += f"/setcoc 4 ‚Üí {GREAT_SF_RULE_STR[4]}ÔºàÂ§ßÊàêÂäü1~5ÔºåÂ§ßÂ§±Ë¥•96~100Ôºâ\n"
            res_str += f"/setcoc 0 ‚Üí ÈªòËÆ§ËßÑÂàôÔºàÂΩìÂâç‰∏∫{GREAT_SF_RULE_STR[GREAT_SF_RULE_DEFAULT]}Ôºâ\n"
            res_str += f"ÂΩìÂâçËßÑÂàôÔºö{GREAT_SF_RULE_STR[int(get_great_sf_rule(group_id))]}"
            yield event.plain_result(res_str)



    
    # ËØÜÂà´ÊâÄÊúâ‰ø°ÊÅØ
    @event_message_type(EventMessageType.GROUP_MESSAGE)
    async def identify_command(self, event: AstrMessageEvent): 

        message = event.message_obj.message_str
        # yield event.plain_result(message)

        random.seed(int(time.time() * 1000))
        
        if not any(message.startswith(prefix) for prefix in self.wakeup_prefix):
            return
        
        message = re.sub(r'\s+', '', message[1:])

        m = re.match(r'^([a-z]+)', message, re.I)

        if not m:
            #raise ValueError('Êó†Ê≥ïËØÜÂà´ÁöÑÊåá‰ª§Ê†ºÂºè!')
            return
        
        cmd  = m.group(1).lower() if m else ""
        expr = message[m.end():].strip()
        
        skill_value = ""
        dice_count = "1"
        if cmd[0:2] == "en":
            sv_match = re.search(r'\d+$', message)
            if sv_match:
                skill_value = sv_match.group()
                expr = message[2:len(message)-len(skill_value)]
                cmd = "en"
            else:
                skill_value = None
                expr = message[2:]
                cmd = "en"
        if cmd[0:2] == "ra":
            sv_match = re.search(r'\d+$', message)
            if sv_match:
                skill_value = sv_match.group()
                expr = message[2:len(message)-len(skill_value)]
                cmd = "ra"
            else:
                skill_value = None
                expr = message[2:]
                cmd = "ra"
            if expr[0] == 'b' or expr[0] == 'p':
                cmd = cmd + expr[0]
                expr = expr[1:]
                dice_count_match = re.search(r'\d+', expr)
                if dice_count_match:
                    dice_count = dice_count_match.group()
                    expr = expr[dice_count_match.end():]
                else:
                    dice_count = "1"

        # result_message = (f"m={m},message={message},cmd={cmd},expr={expr}.")
        # yield event.plain_result(result_message)

        if cmd == "r":
            await self.handle_roll_dice(event, expr)
        elif cmd == "rd":
            await self.handle_roll_dice(event, "d"+expr)
        elif cmd == "rh":
            async for result in self.roll_hidden(event):
                yield result
        elif cmd == "rab":
            async for result in self.roll_attribute_bonus(event, dice_count, expr, skill_value):
                yield result
        elif cmd == "rap":
            async for result in self.roll_attribute_penalty(event, dice_count, expr, skill_value):
                yield result
        elif cmd == "ra":
            async for result in self.roll_attribute(event, expr, skill_value):
                yield result
        elif cmd == "en":
            async for result in self.grow_up(event, expr, skill_value):
                yield result
        elif cmd == "sc":
            async for result in self.san_check(event, expr):  
                yield result
        elif cmd == "li":
            async for result in self.long_term_insanity_command(event):
                yield result
        elif cmd == "ti":
            async for result in self.temporary_insanity_command(event):
                yield result
        elif cmd == "ri":
            async for result in self.roll_initiative(event, expr):
                yield result

    # # log save    
    # @command_group("log")
    # async def log(self, event: AstrMessageEvent, command: str = None):
    #     if command == 'on':
    #         pass
    #     elif command == 'off':
    #         pass
    #     elif command == 'end':
    #         pass
    #     elif command == 'help':
    #         user_id = event.get_sender_id()
    #         group_id = event.get_group_id()
    #         client = event.bot  # Ëé∑ÂèñÊú∫Âô®‰∫∫ Client
    #         message_id = event.message_obj.message_id
    #         payloads = {
    #             "group_id": group_id,
    #             "message": [
    #                 {
    #                     "type": "reply",
    #                     "data": {
    #                         "id": message_id
    #                     }
    #                 },
    #                 {
    #                     "type": "text",
    #                     "data": {
    #                         "text": log_help_str
    #                     }
    #                 }
    #             ]
    #         }

    #         ret = await client.api.call_action("send_group_msg", **payloads)
    #     else:
    #         user_id = event.get_sender_id()
    #         group_id = event.get_group_id()
    #         client = event.bot  # Ëé∑ÂèñÊú∫Âô®‰∫∫ Client
    #         message_id = event.message_obj.message_id
    #         payloads = {
    #             "group_id": group_id,
    #             "message": [
    #                 {
    #                     "type": "reply",
    #                     "data": {
    #                         "id": message_id
    #                     }
    #                 },
    #                 {
    #                     "type": "text",
    #                     "data": {
    #                         "text": f"‰∫öÊâòËéâËøòÊ≤°ÊúâÂΩïÂÖ•Êåá‰ª§{command}Âô¢...ËØ∑ËæìÂÖ•\".log help\"Êü•ËØ¢ÂèØÁî®ÂëΩ‰ª§"
    #                     }
    #                 }
    #             ]
    #         }

    #         ret = await client.api.call_action("send_group_msg", **payloads)

